import * as CML from '@anastasia-labs/cardano-multiplatform-lib-nodejs';

type CostModel = Record<string, number>;
type CostModels = Record<PlutusVersion, CostModel>;
type ProtocolParameters = {
    minFeeA: number;
    minFeeB: number;
    maxTxSize: number;
    maxValSize: number;
    keyDeposit: bigint;
    poolDeposit: bigint;
    drepDeposit: bigint;
    govActionDeposit: bigint;
    priceMem: number;
    priceStep: number;
    maxTxExMem: bigint;
    maxTxExSteps: bigint;
    coinsPerUtxoByte: bigint;
    collateralPercentage: number;
    maxCollateralInputs: number;
    minFeeRefScriptCostPerByte: number;
    costModels: CostModels;
};
type Slot = number;
interface Provider {
    getProtocolParameters(): Promise<ProtocolParameters>;
    /** Query UTxOs by address or payment credential. */
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    /** Query UTxOs by address or payment credential filtered by a specific unit. */
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    /** Query a UTxO by a unit. It needs to be an NFT (or optionally the entire supply in one UTxO). */
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    /** Query UTxOs by the output reference (tx hash and index). */
    getUtxosByOutRef(outRefs: Array<OutRef>): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}
/**
 * Follows WebSocket API Reference [ScriptPurpose](https://ogmios.dev/api/#schema-ScriptPurpose)
 */
type RedeemerTag = "spend" | "mint" | "publish" | "withdraw" | "vote" | "propose";
type EvalRedeemer = {
    ex_units: {
        mem: number;
        steps: number;
    };
    redeemer_index: number;
    redeemer_tag: RedeemerTag;
};
type Credential = {
    type: "Key" | "Script";
    hash: KeyHash | ScriptHash;
};
/** Concatenation of policy id and asset name in Hex. */
type Unit = string;
type Assets = Record<Unit | "lovelace", bigint>;
type ScriptType = "Native" | PlutusVersion;
type PlutusVersion = "PlutusV1" | "PlutusV2" | "PlutusV3";
/** Hex */
type PolicyId = string;
type Script = {
    type: ScriptType;
    script: string;
};
type Validator = MintingPolicy | SpendingValidator | CertificateValidator | WithdrawalValidator | VoteValidator | ProposeValidator;
type MintingPolicy = Script;
type SpendingValidator = Script;
type CertificateValidator = Script;
type WithdrawalValidator = Script;
type VoteValidator = Script;
type ProposeValidator = Script;
/** Bech32 */
type Address = string;
/** Bech32 */
type RewardAddress = string;
/** Hex */
type PaymentKeyHash = string;
/** Hex */
type StakeKeyHash = string;
/** Hex */
type KeyHash = string | PaymentKeyHash | StakeKeyHash;
/** Hex */
type VrfKeyHash = string;
/** Hex */
type ScriptHash = string;
/** Hex */
type TxHash = string;
/** Bech32 */
type PoolId = string;
/** Hex */
type Datum = string;
/**
 * **hash** adds the datum hash to the output.
 *
 * **asHash** hashes the datum and adds the datum hash to the output and the datum to the witness set.
 *
 * **inline** adds the datum to the output.
 *
 * **scriptRef** will add any script to the output.
 *
 * You can either specify **hash**, **asHash** or **inline**, only one option is allowed.
 */
type OutputData = {
    hash?: DatumHash;
    asHash?: Datum;
    inline?: Datum;
    scriptRef?: Script;
};
/** Hex */
type DatumHash = string;
/** Hex (Redeemer is only PlutusData, same as Datum) */
type Redeemer = string;
/** TODO docs  */
type RedeemerBuilder = {
    kind: "selected";
    makeRedeemer: (inputIndices: bigint[]) => Redeemer;
    inputs: UTxO[];
} | {
    kind: "self";
    makeRedeemer: (inputIndex: bigint) => Redeemer;
    inputs?: UTxO[];
};
type Lovelace = bigint;
type Label = number;
/** Hex */
type TransactionWitnesses = string;
/** Hex */
type Transaction = string;
/** Bech32 */
type PrivateKey = string;
/** Bech32 */
type PublicKey = string;
/** Hex */
type ScriptRef = string;
/** Hex */
type Payload = string;
type UTxO = OutRef & TxOutput;
type OutRef = {
    txHash: TxHash;
    outputIndex: number;
};
type TxOutput = {
    address: Address;
    assets: Assets;
    datumHash?: DatumHash | null;
    datum?: Datum | null;
    scriptRef?: Script | null;
};
type AddressType = "Base" | "Enterprise" | "Pointer" | "Reward" | "Byron";
type Network = "Mainnet" | "Preview" | "Preprod" | "Custom";
type AddressDetails = {
    type: AddressType;
    networkId: number;
    address: {
        bech32: Address;
        hex: string;
    };
    paymentCredential?: Credential;
    stakeCredential?: Credential;
};
type Delegation = {
    poolId: PoolId | null;
    rewards: Lovelace;
};
/**
 * A wallet that can be constructed from external data e.g utxos and an address.
 * It doesn't allow you to sign transactions/messages. This needs to be handled separately.
 */
interface ExternalWallet {
    address: Address;
    utxos?: UTxO[];
    rewardAddress?: RewardAddress;
}
type SignedMessage = {
    signature: string;
    key: string;
};
interface Wallet {
    overrideUTxOs(utxos: UTxO[]): void;
    address(): Promise<Address>;
    rewardAddress(): Promise<RewardAddress | null>;
    getUtxos(): Promise<UTxO[]>;
    getUtxosCore(): Promise<Array<CML.TransactionUnspentOutput>>;
    getDelegation(): Promise<Delegation>;
    signTx(tx: CML.Transaction): Promise<CML.TransactionWitnessSet>;
    signMessage(address: Address | RewardAddress, payload: Payload): Promise<SignedMessage>;
    submitTx(signedTx: Transaction): Promise<TxHash>;
}
/** JSON object */
type Json = any;
/** Time in milliseconds */
type UnixTime = number;
type PoolParams = {
    poolId: PoolId;
    vrfKeyHash: VrfKeyHash;
    pledge: Lovelace;
    cost: Lovelace;
    margin: number;
    rewardAddress: RewardAddress;
    owners: Array<RewardAddress>;
    relays: Array<Relay>;
    metadataUrl?: string;
};
type Relay = {
    type: "SingleHostIp" | "SingleHostDomainName" | "MultiHost";
    ipV4?: string;
    ipV6?: string;
    port?: number;
    domainName?: string;
};
/**
 * Represents a cardano-cli JSON script syntax
 *
 * Native type follows the standard described in the
 * {@link https://github.com/IntersectMBO/cardano-node/blob/1.26.1-with-cardano-cli/doc/reference/simple-scripts.md#json-script-syntax JSON script syntax documentation}.
 */
type Native = {
    type: "sig";
    keyHash: string;
} | {
    type: "before";
    slot: number;
} | {
    type: "after";
    slot: number;
} | {
    type: "all";
    scripts: ReadonlyArray<Native>;
} | {
    type: "any";
    scripts: ReadonlyArray<Native>;
} | {
    type: "atLeast";
    required: number;
    scripts: ReadonlyArray<Native>;
};
type SlotConfig = {
    zeroTime: UnixTime;
    zeroSlot: Slot;
    slotLength: number;
};
type Exact<T> = T extends infer U ? U : never;
type Metadata = {
    222: {
        name: string;
        image: string;
        mediaType?: string;
        description?: string;
        files?: {
            name?: string;
            mediaType: string;
            src: string;
        }[];
        [key: string]: Json;
    };
    333: {
        name: string;
        description: string;
        ticker?: string;
        url?: string;
        logo?: string;
        decimals?: number;
        [key: string]: Json;
    };
    444: Metadata["222"] & {
        decimals?: number;
    };
};
type DatumJson = {
    int?: number;
    bytes?: string;
    list?: Array<DatumJson>;
    map?: Array<{
        k: unknown;
        v: unknown;
    }>;
    fields?: Array<DatumJson>;
    [constructor: string]: unknown;
};
type Anchor = {
    url: string;
    dataHash: string;
};
type AlwaysAbstain = {
    __typename: "AlwaysAbstain";
};
type AlwaysNoConfidence = {
    __typename: "AlwaysNoConfidence";
};
type DRep = Credential | AlwaysAbstain | AlwaysNoConfidence;
declare const isDRepCredential: (deleg: DRep) => deleg is Credential;
declare const isDRepAlwaysAbstain: (deleg: DRep) => deleg is AlwaysAbstain;
declare const isDRepAlwaysNoConfidence: (deleg: DRep) => deleg is AlwaysNoConfidence;
declare const toCMLDRep: (drep: DRep) => CML.DRep;

type WalletApi = {
    getNetworkId(): Promise<number>;
    getUtxos(): Promise<string[] | undefined>;
    getBalance(): Promise<string>;
    getUsedAddresses(): Promise<string[]>;
    getUnusedAddresses(): Promise<string[]>;
    getChangeAddress(): Promise<string>;
    getRewardAddresses(): Promise<string[]>;
    signTx(tx: string, partialSign: boolean): Promise<string>;
    signData(address: string, payload: string): Promise<{
        signature: string;
        key: string;
    }>;
    submitTx(tx: string): Promise<string>;
    getCollateral(): Promise<string[]>;
    experimental: {
        getCollateral(): Promise<string[]>;
        on(eventName: string, callback: (...args: unknown[]) => void): void;
        off(eventName: string, callback: (...args: unknown[]) => void): void;
    };
};
type Cardano = {
    [key: string]: {
        name: string;
        icon: string;
        apiVersion: string;
        enable(): Promise<WalletApi>;
        isEnabled(): Promise<boolean>;
    };
};
declare global {
    interface Window {
        cardano: Cardano;
    }
}

export { type Address, type AddressDetails, type AddressType, type AlwaysAbstain, type AlwaysNoConfidence, type Anchor, type Assets, type Cardano, type CertificateValidator, type CostModels, type Credential, type DRep, type Datum, type DatumHash, type DatumJson, type Delegation, type EvalRedeemer, type Exact, type ExternalWallet, type Json, type KeyHash, type Label, type Lovelace, type Metadata, type MintingPolicy, type Native, type Network, type OutRef, type OutputData, type Payload, type PaymentKeyHash, type PlutusVersion, type PolicyId, type PoolId, type PoolParams, type PrivateKey, type ProposeValidator, type ProtocolParameters, type Provider, type PublicKey, type Redeemer, type RedeemerBuilder, type RedeemerTag, type Relay, type RewardAddress, type Script, type ScriptHash, type ScriptRef, type ScriptType, type SignedMessage, type Slot, type SlotConfig, type SpendingValidator, type StakeKeyHash, type Transaction, type TransactionWitnesses, type TxHash, type TxOutput, type UTxO, type Unit, type UnixTime, type Validator, type VoteValidator, type VrfKeyHash, type Wallet, type WalletApi, type WithdrawalValidator, isDRepAlwaysAbstain, isDRepAlwaysNoConfidence, isDRepCredential, toCMLDRep };

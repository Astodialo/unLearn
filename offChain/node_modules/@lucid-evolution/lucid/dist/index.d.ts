import { Network, Wallet, PrivateKey, TransactionWitnesses, Address, UTxO, Assets, TxOutput, ScriptType, RedeemerBuilder, Script, RewardAddress, PaymentKeyHash, StakeKeyHash, Lovelace, Anchor, PoolId, Redeemer, DRep, Label, Provider, Transaction, WalletApi, Credential, OutRef, Delegation, ProtocolParameters } from '@lucid-evolution/core-types';
export * from '@lucid-evolution/core-types';
import * as CML from '@anastasia-labs/cardano-multiplatform-lib-nodejs';
export { CML };
import * as effect_Either from 'effect/Either';
import { Either } from 'effect/Either';
import { Effect } from 'effect';
import * as effect_Cause from 'effect/Cause';
import * as effect_Types from 'effect/Types';
import { Data } from '@lucid-evolution/plutus';
export * from '@lucid-evolution/plutus';
export * from '@lucid-evolution/core-utils';
export * from '@lucid-evolution/provider';
export * from '@lucid-evolution/sign_data';
export * from '@lucid-evolution/utils';
export * from '@lucid-evolution/wallet';

declare const makeReturn: <A, E>(program: Effect.Effect<A, E>) => {
    unsafeRun: () => Promise<A>;
    safeRun: () => Promise<effect_Either.Either<A, E>>;
    program: () => Effect.Effect<A, E, never>;
};

type Hash = string;
type CBORHex = string;
type OutputDatum = {
    kind: "hash";
    value: Hash;
} | {
    kind: "asHash";
    value: CBORHex;
} | {
    kind: "inline";
    value: CBORHex;
};

type TransactionMetadata = string | number | Uint8Array | ReadonlyArray<TransactionMetadata> | {
    [key: string]: TransactionMetadata;
};

declare const ERROR_MESSAGE: {
    readonly MULTIPLE_POLICIES: "MULTIPLE_POLICIES: Only one policy id allowed. You can chain multiple mintAssets functions together if you need to mint assets with different policy ids. ";
    readonly EMPTY_UTXO: "EMPTY_UTXO: UTxO array is empty. If a Tx has been recently submitted, consider waiting for chain sync";
    readonly MISSING_WALLET: "MISSING_WALLET: please ensure that your wallet has been properly configured and initialized";
    readonly MISSING_REDEEMER: "MISSING_REDEEMER: redeemer can not be undefined";
    readonly DATUM_NOT_SET: "DATUM_NOT_SET: Script inputs becomes unspendable without datum.";
    readonly EMPTY_ASSETS: "EMPTY_ASSETS: Attempting to pay to an address with an empty assets object";
    readonly MISSING_REWARD_TYPE: "MISSING_REWARD_TYPE: Address type must be Reward type.";
    readonly MISSING_STAKE_CREDENTIAL: "MISSING_STAKE_CREDENTIAL: Address does not contain stake credential";
    readonly MISSING_PAYMENT_CREDENTIAL: "MISSING_PAYMENT_CREDENTIAL: Address does not contain payment credential";
    readonly INVALID_METADATA: "INVALID_METADATA: metadata is invalid";
    readonly SCRIPT_CREDENTIAL_NOT_ALLOWED: "SCRIPT_CREDENTIAL_NOT_ALLOWED: Only verification key credential is allowed";
    readonly INVALID_SCRIPT: "INVALID_SCRIPT: Script is invalid";
    readonly EXPECTED_KEY_HASH: "EXPECTED_KEY_HASH";
    readonly INVALID_NETWORK: (address: string, actualNetworkId: number, network: Network) => string;
    readonly MISSING_SCRIPT: (hash: string) => string;
    readonly MISSING_POLICY: (policyId: string) => string;
};
declare const TxBuilderError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "TxBuilderError";
} & Readonly<A>;
declare class TxBuilderError extends TxBuilderError_base<{
    readonly cause: unknown;
}> {
    get message(): string;
}
type TransactionError = RunTimeError | TxBuilderError;
declare const TxSignerError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "TxSignerError";
} & Readonly<A>;
declare class TxSignerError extends TxSignerError_base<{
    readonly cause: unknown;
}> {
    get message(): string;
}
type TransactionSignError = RunTimeError | TxSignerError;
declare const TxSubmitError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "TxSubmitError";
} & Readonly<A>;
declare class TxSubmitError extends TxSubmitError_base<{
    readonly cause: unknown;
}> {
    get message(): string;
}
declare const RunTimeError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "RunTimeError";
} & Readonly<A>;
declare class RunTimeError extends RunTimeError_base<{
    cause: unknown;
}> {
    get message(): string;
}

interface TxSigned {
    /** Submits the transaction and returns the transaction hash.
     *
     * Supports both canonical and non-canonical formats.
     *
     * Canonical format follows [RFC 7049 Section 3.9](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9) rules
     *
     * Non-canonical format example:
     * ```typescript
     * .submit();
     * ```
     * Canonical format example:
     * ```typescript
     * .submit({ canonical: true });
     * ```
     */
    submit: (options?: {
        canonical: boolean;
    }) => Promise<string>;
    /** Submits the transaction and returns the transaction hash or error as an effect.
     *
     * Supports both canonical and non-canonical formats.
     *
     * Canonical format follows [RFC 7049 Section 3.9](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9) rules
     *
     * Non-canonical format example:
     * ```typescript
     * .submitProgram();
     * ```
     * Canonical format example:
     * ```typescript
     * .submitProgram({ canonical: true });
     * ```
     */
    submitProgram: (options?: {
        canonical: boolean;
    }) => Effect.Effect<string, TxSubmitError, never>;
    /** Safely submits the transaction, returning the transaction hash or an error as promise either type.
     *
     * Supports both canonical and non-canonical formats.
     *
     * Canonical format follows [RFC 7049 Section 3.9](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9) rules
     *
     * Non-canonical format example:
     * ```typescript
     * .submitSafe();
     * ```
     * Canonical format example:
     * ```typescript
     * .submitSafe({ canonical: true });
     * ```
     */
    submitSafe: (options?: {
        canonical: boolean;
    }) => Promise<Either<string, TxSubmitError>>;
    /**
     * Converts the transaction to CBOR (Concise Binary Object Representation) format.
     *
     * Supports both canonical and non-canonical formats.
     *
     * Canonical format follows [RFC 7049 Section 3.9](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9) rules
     *
     * Non-canonical format example:
     * ```typescript
     * .toCBOR();
     * ```
     * Canonical format example:
     * ```typescript
     * .toCBOR({ canonical: true });
     * ```
     */
    toCBOR: (options?: {
        canonical: boolean;
    }) => CBORHex;
    toTransaction: () => CML.Transaction;
    /** Converts the transaction (transaction body and witnesses) to JSON format. */
    toJSON: () => object;
    /** Computes the hash of the transaction. */
    toHash: () => Hash;
}
declare const makeSubmit: (wallet: Wallet, txSigned: CML.Transaction) => TxSigned;

interface TxSignBuilderConfig {
    txComplete: CML.Transaction;
    witnessSetBuilder: CML.TransactionWitnessSetBuilder;
    programs: Effect.Effect<void, TransactionSignError, never>[];
    lucidConfig: LucidConfig;
    fee: number;
    exUnits: {
        cpu: number;
        mem: number;
    } | null;
}
interface TxSignBuilder {
    sign: {
        /** Signs the transaction with a wallet. */
        withWallet: () => TxSignBuilder;
        /** Signs the transaction with a private key. */
        withPrivateKey: (privateKey: PrivateKey) => TxSignBuilder;
    };
    partialSign: {
        /** Partially signs the transaction with a wallet. */
        withWallet: () => Promise<TransactionWitnesses>;
        /** Partially signs the transaction with a wallet and returns an effect. */
        withWalletEffect: () => Effect.Effect<TransactionWitnesses, TransactionSignError>;
        /** Safely partially signs the transaction with a wallet. */
        withWalletSafe: () => Promise<Either<TransactionWitnesses, TransactionSignError>>;
        /** Partially signs the transaction with a private key. */
        withPrivateKey: (privateKey: PrivateKey) => Promise<TransactionWitnesses>;
        /** Partially signs the transaction with a private key and returns an effect. */
        withPrivateKeyEffect: (privateKey: PrivateKey) => Effect.Effect<TransactionWitnesses, TransactionSignError>;
        /** Safely partially signs the transaction with a private key. */
        withPrivateKeySafe: (privateKey: PrivateKey) => Promise<Either<TransactionWitnesses, TransactionSignError>>;
    };
    /** Assembles the transaction with the given witnesses.  */
    assemble: (witnesses: TransactionWitnesses[]) => TxSignBuilder;
    /**
     * Converts the transaction to CBOR (Concise Binary Object Representation) format.
     *
     * Supports both canonical and non-canonical formats.
     *
     * Canonical format follows [RFC 7049 Section 3.9](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9) rules
     *
     * Non-canonical format example:
     * ```typescript
     * .toCBOR();
     * ```
     * Canonical format example:
     * ```typescript
     * .toCBOR({ canonical: true });
     * ```
     */
    toCBOR: (options?: {
        canonical: boolean;
    }) => CBORHex;
    toTransaction: () => CML.Transaction;
    /** Converts the transaction body to JSON format. */
    toJSON: () => object;
    /** Computes the hash of the transaction body. */
    toHash: () => Hash;
    complete: () => Promise<TxSigned>;
    /** Completes the transaction and returns an effect. */
    completeProgram: () => Effect.Effect<TxSigned, TransactionSignError, never>;
    /** Safely completes the transaction. */
    completeSafe: () => Promise<Either<TxSigned, TransactionSignError>>;
}
declare const makeTxSignBuilder: (lucidConfig: LucidConfig, tx: CML.Transaction) => TxSignBuilder;

type CompleteOptions = {
    coinSelection?: boolean;
    changeAddress?: Address;
    localUPLCEval?: boolean;
    setCollateral?: bigint;
    canonical?: boolean;
};

type TxBuilderConfig = {
    readonly lucidConfig: LucidConfig;
    readonly txBuilder: CML.TransactionBuilder;
    walletInputs: UTxO[];
    collectedInputs: UTxO[];
    readInputs: UTxO[];
    consumedInputs: UTxO[];
    totalOutputAssets: Assets;
    payToOutputs: TxOutput[];
    mintedAssets: Assets;
    scripts: Map<string, {
        type: ScriptType;
        script: string;
    }>;
    programs: Effect.Effect<void, TransactionError, never>[];
    partialPrograms: Map<RedeemerBuilder, (redeemer?: string) => Effect.Effect<void, TransactionError, never>>;
    minFee: bigint | undefined;
};
type TxBuilder = {
    readFrom: (utxos: UTxO[]) => TxBuilder;
    collectFrom: (utxos: UTxO[], redeemer?: string | RedeemerBuilder) => TxBuilder;
    pay: {
        ToAddress: (address: string, assets: Assets) => TxBuilder;
        ToAddressWithData: (address: string, outputDatum: OutputDatum, assets?: Assets | undefined, scriptRef?: Script | undefined) => TxBuilder;
        ToContract: (address: string, outputDatum: OutputDatum, assets?: Assets | undefined, scriptRef?: Script | undefined) => TxBuilder;
    };
    addSigner: (address: Address | RewardAddress) => TxBuilder;
    addSignerKey: (keyHash: PaymentKeyHash | StakeKeyHash) => TxBuilder;
    /**
     * NOTE: Deprecate in future version
     */
    registerStake: (rewardAddress: RewardAddress) => TxBuilder;
    /**
     * NOTE: Deprecate in future version
     */
    deRegisterStake: (rewardAddress: RewardAddress, redeemer?: string) => TxBuilder;
    withdraw: (rewardAddress: RewardAddress, amount: Lovelace, redeemer?: string | RedeemerBuilder) => TxBuilder;
    register: {
        Stake: (rewardAddress: RewardAddress) => TxBuilder;
        DRep: (rewardAddress: RewardAddress, anchor?: Anchor, redeemer?: string) => TxBuilder;
    };
    deregister: {
        Stake: (rewardAddress: RewardAddress, redeemer?: string) => TxBuilder;
        DRep: (rewardAddress: RewardAddress, redeemer?: string) => TxBuilder;
    };
    mintAssets: (assets: Assets, redeemer?: string | RedeemerBuilder) => TxBuilder;
    validFrom: (unixTime: number) => TxBuilder;
    validTo: (unixTime: number) => TxBuilder;
    /**
     * NOTE: Deprecate in future version
     */
    delegateTo: (rewardAddress: RewardAddress, poolId: PoolId, redeemer?: Redeemer) => TxBuilder;
    delegate: {
        ToPool: (rewardAddress: RewardAddress, poolId: PoolId, redeemer?: Redeemer) => TxBuilder;
        VoteToDRep: (rewardAddress: RewardAddress, drep: DRep, redeemer?: Redeemer) => TxBuilder;
        VoteToPoolAndDRep: (rewardAddress: RewardAddress, poolId: PoolId, drep: DRep, redeemer?: Redeemer) => TxBuilder;
    };
    registerAndDelegate: {
        ToPool: (rewardAddress: RewardAddress, poolId: PoolId, redeemer?: Redeemer) => TxBuilder;
        ToDRep: (rewardAddress: RewardAddress, drep: DRep, redeemer?: Redeemer) => TxBuilder;
        ToPoolAndDRep: (rewardAddress: RewardAddress, poolId: PoolId, drep: DRep, redeemer?: Redeemer) => TxBuilder;
    };
    updateDRep: (rewardAddress: RewardAddress, anchor?: Anchor, redeemer?: Redeemer) => TxBuilder;
    authCommitteeHot: (coldAddress: RewardAddress, hotAddress: RewardAddress) => TxBuilder;
    resignCommitteeHot: (coldAddress: RewardAddress, anchor?: Anchor) => TxBuilder;
    attachMetadata: (label: Label, metadata: TransactionMetadata) => TxBuilder;
    attach: {
        Script: (script: Script) => TxBuilder;
        SpendingValidator: (spendingValidator: Script) => TxBuilder;
        MintingPolicy: (mintingPolicy: Script) => TxBuilder;
        CertificateValidator: (certValidator: Script) => TxBuilder;
        WithdrawalValidator: (withdrawalValidator: Script) => TxBuilder;
        VoteValidator: (voteValidator: Script) => TxBuilder;
        ProposeValidator: (proposeValidator: Script) => TxBuilder;
    };
    compose: (tx: TxBuilder | null) => TxBuilder;
    setMinFee: (fee: bigint) => TxBuilder;
    complete: (options?: CompleteOptions) => Promise<TxSignBuilder>;
    completeProgram: (options?: CompleteOptions) => Effect.Effect<TxSignBuilder, TransactionError>;
    completeSafe: (options?: CompleteOptions) => Promise<Either<TxSignBuilder, TransactionError>>;
    chainProgram: () => Effect.Effect<[
        UTxO[],
        UTxO[],
        TxSignBuilder
    ], TransactionError, never>;
    chain: () => Promise<[UTxO[], UTxO[], TxSignBuilder]>;
    chainSafe: () => Promise<Either<[UTxO[], UTxO[], TxSignBuilder], TransactionError>>;
    /**
     * **Warning:** This method executes all programs and mutates the TxBuilder state.
     *
     * Calling `.complete()` after executing this function will lead to unexpected behavior.
     *
     * It is recommended to call `.config()` only for debugging purposes
     */
    config: () => Promise<TxBuilderConfig>;
    /**
     * Returns the current lucid instance configuration
     */
    lucidConfig: () => LucidConfig;
};
declare function makeTxBuilder(lucidConfig: LucidConfig): TxBuilder;

type LucidEvolution = {
    config: () => LucidConfig;
    wallet: () => Wallet;
    overrideUTxOs: (utxos: UTxO[]) => void;
    switchProvider: (provider: Provider) => Promise<void>;
    newTx: () => TxBuilder;
    fromTx: (tx: Transaction) => TxSignBuilder;
    selectWallet: {
        fromSeed: (seed: string, options?: {
            addressType?: "Base" | "Enterprise";
            accountIndex?: number;
            password?: string;
        }) => void;
        fromPrivateKey: (privateKey: PrivateKey) => void;
        fromAPI: (walletAPI: WalletApi) => void;
        fromAddress: (address: string, utxos: UTxO[]) => void;
    };
    currentSlot: () => number;
    utxosAt: (addressOrCredential: string | Credential) => Promise<UTxO[]>;
    utxosAtWithUnit: (addressOrCredential: string | Credential, unit: string) => Promise<UTxO[]>;
    utxoByUnit: (unit: string) => Promise<UTxO>;
    utxosByOutRef: (outRefs: OutRef[]) => Promise<UTxO[]>;
    delegationAt: (rewardAddress: string) => Promise<Delegation>;
    awaitTx: (txHash: string, checkInterval?: number | undefined) => Promise<boolean>;
    datumOf: <T extends Data>(utxo: UTxO, type?: T | undefined) => Promise<T>;
    metadataOf: <T = any>(unit: string) => Promise<T>;
};
type LucidConfig = {
    provider: Provider;
    network: Network;
    wallet: Wallet | undefined;
    txbuilderconfig: CML.TransactionBuilderConfig;
    costModels: CML.CostModels;
    protocolParameters: ProtocolParameters;
};
declare const Lucid: (provider: Provider, network: Network) => Promise<LucidEvolution>;

export { type CBORHex, ERROR_MESSAGE, type Hash, Lucid, type LucidConfig, type LucidEvolution, type OutputDatum, RunTimeError, type TransactionError, type TransactionSignError, type TxBuilder, type TxBuilderConfig, TxBuilderError, type TxSignBuilder, type TxSignBuilderConfig, type TxSigned, TxSignerError, TxSubmitError, makeReturn, makeSubmit, makeTxBuilder, makeTxSignBuilder };

// src/core.ts
import * as CML from "@anastasia-labs/cardano-multiplatform-lib-nodejs";

// src/blockfrost.ts
import { fromHex, sleep } from "@lucid-evolution/core-utils";
import {
  applyDoubleCborEncoding,
  scriptFromNative
} from "@lucid-evolution/utils";

// package.json
var package_default = {
  name: "@lucid-evolution/provider",
  version: "0.1.69",
  description: "",
  main: "./dist/index.js",
  types: "./dist/index.d.ts",
  type: "module",
  exports: {
    ".": {
      require: "./dist/index.cjs",
      import: "./dist/index.js",
      types: "./dist/index.d.ts"
    }
  },
  files: [
    "dist"
  ],
  publishConfig: {
    access: "public"
  },
  scripts: {
    build: "tsup src/index.ts --format esm,cjs --dts --clean",
    clean: "rm -rf .turbo && rm -rf node_modules && rm -rf dist",
    test: "vitest run"
  },
  keywords: [],
  author: "",
  license: "MIT",
  browser: {
    "@anastasia-labs/cardano-multiplatform-lib-nodejs": "@anastasia-labs/cardano-multiplatform-lib-browser"
  },
  dependencies: {
    "@anastasia-labs/cardano-multiplatform-lib-browser": "6.0.2-2",
    "@anastasia-labs/cardano-multiplatform-lib-nodejs": "6.0.2-2",
    "@effect/platform": "^0.59.2",
    "@effect/schema": "^0.68.26",
    "@lucid-evolution/core-types": "workspace:*",
    "@lucid-evolution/core-utils": "workspace:*",
    "@lucid-evolution/utils": "workspace:*",
    "@lucid-evolution/wallet": "workspace:*",
    effect: "^3.5.6"
  },
  devDependencies: {
    "@types/node": "^20.12.8",
    tsup: "^8.0.2",
    typescript: "^5.4.5",
    vitest: "^2.0.4"
  }
};

// src/internal/blockfrost.ts
import { pipe, Record } from "effect";
var toAditionalUTXOs = (utxos) => (utxos || []).map((utxo) => [
  {
    txId: utxo.txHash,
    index: utxo.outputIndex
  },
  {
    address: utxo.address,
    value: {
      coins: Number(utxo.assets["lovelace"]),
      assets: fromAssets(utxo.assets)
    },
    datumHash: utxo.datumHash,
    datum: utxo.datum,
    script: toTxOutScript(utxo.scriptRef)
  }
]);
var toTxOutScript = (scriptRef) => {
  if (scriptRef) {
    switch (scriptRef.type) {
      case "PlutusV1":
        return { "plutus:v1": scriptRef.script };
      case "PlutusV2":
        return { "plutus:v2": scriptRef.script };
      case "PlutusV3":
        return { "plutus:v3": scriptRef.script };
      default:
        return void 0;
    }
  }
};
var fromAssets = (assets) => pipe(
  Record.remove(assets, "lovelace"),
  Record.mapEntries((amount, unit) => [
    unit.length === 56 ? unit.slice(0, 56) : unit.slice(0, 56) + "." + unit.slice(56),
    Number(amount)
  ]),
  (r) => Record.isEmptyRecord(r) ? void 0 : r
);

// src/blockfrost.ts
var Blockfrost = class {
  url;
  projectId;
  constructor(url, projectId) {
    this.url = url;
    this.projectId = projectId || "";
  }
  async getProtocolParameters() {
    const result = await fetch(`${this.url}/epochs/latest/parameters`, {
      headers: { project_id: this.projectId, lucid }
    }).then((res) => res.json());
    return {
      minFeeA: parseInt(result.min_fee_a),
      minFeeB: parseInt(result.min_fee_b),
      maxTxSize: parseInt(result.max_tx_size),
      maxValSize: parseInt(result.max_val_size),
      keyDeposit: BigInt(result.key_deposit),
      poolDeposit: BigInt(result.pool_deposit),
      drepDeposit: BigInt(result.drep_deposit),
      govActionDeposit: BigInt(result.gov_action_deposit),
      priceMem: parseFloat(result.price_mem),
      priceStep: parseFloat(result.price_step),
      maxTxExMem: BigInt(result.max_tx_ex_mem),
      maxTxExSteps: BigInt(result.max_tx_ex_steps),
      coinsPerUtxoByte: BigInt(result.coins_per_utxo_size),
      collateralPercentage: parseInt(result.collateral_percent),
      maxCollateralInputs: parseInt(result.max_collateral_inputs),
      minFeeRefScriptCostPerByte: parseInt(
        result.min_fee_ref_script_cost_per_byte
      ),
      costModels: result.cost_models
    };
  }
  async getUtxos(addressOrCredential) {
    const queryPredicate = (() => {
      if (typeof addressOrCredential === "string") return addressOrCredential;
      const credentialBech32 = addressOrCredential.type === "Key" ? CML.Ed25519KeyHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      ) : CML.ScriptHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      );
      return credentialBech32;
    })();
    let result = [];
    let page = 1;
    while (true) {
      const pageResult = await fetch(
        `${this.url}/addresses/${queryPredicate}/utxos?page=${page}`,
        { headers: { project_id: this.projectId, lucid } }
      ).then((res) => res.json());
      if (pageResult.error) {
        if (pageResult.status_code === 404) {
          return [];
        } else {
          throw new Error("Could not fetch UTxOs from Blockfrost. Try again.");
        }
      }
      result = result.concat(pageResult);
      if (pageResult.length <= 0) break;
      page++;
    }
    return this.blockfrostUtxosToUtxos(result);
  }
  async getUtxosWithUnit(addressOrCredential, unit) {
    const queryPredicate = (() => {
      if (typeof addressOrCredential === "string") return addressOrCredential;
      const credentialBech32 = addressOrCredential.type === "Key" ? CML.Ed25519KeyHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      ) : CML.ScriptHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      );
      return credentialBech32;
    })();
    let result = [];
    let page = 1;
    while (true) {
      const pageResult = await fetch(
        `${this.url}/addresses/${queryPredicate}/utxos/${unit}?page=${page}`,
        { headers: { project_id: this.projectId, lucid } }
      ).then((res) => res.json());
      if (pageResult.error) {
        if (pageResult.status_code === 404) {
          return [];
        } else {
          throw new Error("Could not fetch UTxOs from Blockfrost. Try again.");
        }
      }
      result = result.concat(pageResult);
      if (pageResult.length <= 0) break;
      page++;
    }
    return this.blockfrostUtxosToUtxos(result);
  }
  async getUtxoByUnit(unit) {
    const addresses = await fetch(
      `${this.url}/assets/${unit}/addresses?count=2`,
      { headers: { project_id: this.projectId, lucid } }
    ).then((res) => res.json());
    if (!addresses || addresses.error) {
      throw new Error("Unit not found.");
    }
    if (addresses.length > 1) {
      throw new Error("Unit needs to be an NFT or only held by one address.");
    }
    const address = addresses[0].address;
    const utxos = await this.getUtxosWithUnit(address, unit);
    if (utxos.length > 1) {
      throw new Error("Unit needs to be an NFT or only held by one address.");
    }
    return utxos[0];
  }
  async getUtxosByOutRef(outRefs) {
    const queryHashes = [...new Set(outRefs.map((outRef) => outRef.txHash))];
    const utxos = await Promise.all(
      queryHashes.map(async (txHash) => {
        const result = await fetch(`${this.url}/txs/${txHash}/utxos`, {
          headers: { project_id: this.projectId, lucid }
        }).then((res) => res.json());
        if (!result || result.error) {
          return [];
        }
        const utxosResult = result.outputs.map(
          (r) => ({
            ...r,
            tx_hash: txHash
          })
        );
        return this.blockfrostUtxosToUtxos(utxosResult);
      })
    );
    return utxos.reduce((acc, utxos2) => acc.concat(utxos2), []).filter(
      (utxo) => outRefs.some(
        (outRef) => utxo.txHash === outRef.txHash && utxo.outputIndex === outRef.outputIndex
      )
    );
  }
  async getDelegation(rewardAddress) {
    const result = await fetch(`${this.url}/accounts/${rewardAddress}`, {
      headers: { project_id: this.projectId, lucid }
    }).then((res) => res.json());
    if (!result || result.error) {
      return { poolId: null, rewards: 0n };
    }
    return {
      poolId: result.pool_id || null,
      rewards: BigInt(result.withdrawable_amount)
    };
  }
  async getDatum(datumHash) {
    const datum = await fetch(`${this.url}/scripts/datum/${datumHash}/cbor`, {
      headers: { project_id: this.projectId, lucid }
    }).then((res) => res.json()).then((res) => res.cbor);
    if (!datum || datum.error) {
      throw new Error(`No datum found for datum hash: ${datumHash}`);
    }
    return datum;
  }
  awaitTx(txHash, checkInterval = 3e3) {
    return new Promise((res) => {
      const confirmation = setInterval(async () => {
        const isConfirmed = await fetch(`${this.url}/txs/${txHash}`, {
          headers: { project_id: this.projectId, lucid }
        }).then((res2) => res2.json());
        if (isConfirmed && !isConfirmed.error) {
          clearInterval(confirmation);
          await new Promise((res2) => setTimeout(() => res2(1), 1e3));
          return res(true);
        }
      }, checkInterval);
    });
  }
  async submitTx(tx) {
    const result = await fetch(`${this.url}/tx/submit`, {
      method: "POST",
      headers: {
        "Content-Type": "application/cbor",
        project_id: this.projectId,
        lucid
      },
      body: fromHex(tx)
    }).then((res) => res.json());
    if (!result || result.error) {
      if (result?.status_code === 400) throw new Error(result.message);
      else throw new Error("Could not submit transaction.");
    }
    return result;
  }
  async blockfrostUtxosToUtxos(result) {
    const utxos = [];
    const batchSize = 10;
    let count = 0;
    for (let i = 0; i < result.length; i += batchSize) {
      const batch = result.slice(i, i + batchSize);
      count += batchSize;
      await handleRateLimit(count);
      const batchResults = await Promise.all(
        batch.map(async (r) => {
          return {
            txHash: r.tx_hash,
            outputIndex: r.output_index,
            assets: Object.fromEntries(
              r.amount.map(({ unit, quantity }) => [unit, BigInt(quantity)])
            ),
            address: r.address,
            datumHash: !r.inline_datum && r.data_hash || void 0,
            datum: r.inline_datum || void 0,
            scriptRef: r.reference_script_hash ? await (async () => {
              const { type } = await fetch(
                `${this.url}/scripts/${r.reference_script_hash}`,
                {
                  headers: { project_id: this.projectId, lucid }
                }
              ).then((res) => res.json());
              const { cbor: script } = await fetch(
                `${this.url}/scripts/${r.reference_script_hash}/cbor`,
                { headers: { project_id: this.projectId, lucid } }
              ).then((res) => res.json());
              switch (type) {
                case "timelock":
                  const { json: native } = await fetch(
                    `${this.url}/scripts/${r.reference_script_hash}/json`,
                    { headers: { project_id: this.projectId, lucid } }
                  ).then((res) => res.json());
                  return scriptFromNative(native);
                case "plutusV1":
                  return {
                    type: "PlutusV1",
                    script: applyDoubleCborEncoding(script)
                  };
                case "plutusV2":
                  return {
                    type: "PlutusV2",
                    script: applyDoubleCborEncoding(script)
                  };
                case "plutusV3":
                  return {
                    type: "PlutusV3",
                    script: applyDoubleCborEncoding(script)
                  };
              }
            })() : void 0
          };
        })
      );
      utxos.push(...batchResults);
    }
    return utxos;
  }
  async evaluateTx(tx, additionalUTxOs) {
    const payload = {
      cbor: tx,
      additionalUtxoSet: toAditionalUTXOs(additionalUTxOs)
    };
    const res = await fetch(`${this.url}/utils/txs/evaluate/utxos`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        project_id: this.projectId,
        lucid
      },
      body: JSON.stringify(payload)
    }).then((res2) => res2.json());
    if (!res || res.fault) {
      const message = res?.status_code === 400 ? res.message : `Could not evaluate the transaction: ${JSON.stringify(res)}. Transaction: ${tx}`;
      throw new Error(message);
    }
    const blockfrostRedeemer = res;
    if (!("EvaluationResult" in blockfrostRedeemer.result)) {
      throw new Error(
        `EvaluateTransaction fails: ${JSON.stringify(blockfrostRedeemer.result)}`
      );
    }
    const evalRedeemers = [];
    Object.entries(blockfrostRedeemer.result.EvaluationResult).forEach(
      ([redeemerPointer, data]) => {
        const [pTag, pIndex] = redeemerPointer.split(":");
        evalRedeemers.push({
          redeemer_tag: pTag,
          redeemer_index: Number(pIndex),
          ex_units: { mem: Number(data.memory), steps: Number(data.steps) }
        });
      }
    );
    return evalRedeemers;
  }
};
var handleRateLimit = async (count) => {
  if (count % 100 === 0) {
    await sleep(5e3);
  } else if (count % 10 === 0) {
    await sleep(500);
  }
};
var lucid = package_default.version;

// src/kupmios.ts
import { applyDoubleCborEncoding as applyDoubleCborEncoding2, fromUnit as fromUnit2 } from "@lucid-evolution/utils";
import * as S3 from "@effect/schema/Schema";
import { Effect, pipe as pipe2, Array as _Array, Schedule, Data } from "effect";
import {
  HttpClient,
  HttpClientRequest,
  HttpClientResponse
} from "@effect/platform";
import { ArrayFormatter } from "@effect/schema";

// src/internal/ogmios.ts
import * as S from "@effect/schema/Schema";
import { fromUnit } from "@lucid-evolution/utils";
var JSONRPCSchema = (schema) => S.extend(
  S.Struct({
    jsonrpc: S.String,
    method: S.optional(S.String),
    id: S.NullOr(S.Number)
  }),
  S.Union(S.Struct({ result: schema }), S.Struct({ error: S.Object }))
);
var LovelaceAsset = S.Struct({
  lovelace: S.Number
});
var TupleNumberFromString = S.compose(
  S.split("/"),
  S.Array(S.NumberFromString)
);
var ProtocolParametersSchema = S.Struct({
  minFeeCoefficient: S.Number,
  minFeeReferenceScripts: S.Struct({
    base: S.Number,
    range: S.Number,
    multiplier: S.Number
  }),
  maxReferenceScriptsSize: S.Struct({
    bytes: S.Number
  }),
  stakePoolVotingThresholds: S.Struct({
    noConfidence: TupleNumberFromString,
    constitutionalCommittee: S.Struct({
      default: TupleNumberFromString,
      stateOfNoConfidence: TupleNumberFromString
    }),
    hardForkInitiation: TupleNumberFromString,
    protocolParametersUpdate: S.Struct({
      security: TupleNumberFromString
    })
  }),
  delegateRepresentativeVotingThresholds: S.Struct({
    noConfidence: TupleNumberFromString,
    constitutionalCommittee: S.Struct({
      default: TupleNumberFromString,
      stateOfNoConfidence: TupleNumberFromString
    }),
    constitution: TupleNumberFromString,
    hardForkInitiation: TupleNumberFromString,
    protocolParametersUpdate: S.Struct({
      network: TupleNumberFromString,
      economic: TupleNumberFromString,
      technical: TupleNumberFromString,
      governance: TupleNumberFromString
    }),
    treasuryWithdrawals: TupleNumberFromString
  }),
  constitutionalCommitteeMinSize: S.optional(S.Number),
  constitutionalCommitteeMaxTermLength: S.Number,
  governanceActionLifetime: S.Number,
  governanceActionDeposit: S.Struct({
    ada: LovelaceAsset
  }),
  delegateRepresentativeDeposit: S.Struct({
    ada: LovelaceAsset
  }),
  delegateRepresentativeMaxIdleTime: S.Number,
  minFeeConstant: S.Struct({ ada: LovelaceAsset }),
  maxBlockBodySize: S.Struct({ bytes: S.Number }),
  maxBlockHeaderSize: S.Struct({ bytes: S.Number }),
  maxTransactionSize: S.Struct({ bytes: S.Number }),
  stakeCredentialDeposit: S.Struct({ ada: LovelaceAsset }),
  stakePoolDeposit: S.Struct({ ada: LovelaceAsset }),
  stakePoolRetirementEpochBound: S.Number,
  desiredNumberOfStakePools: S.Number,
  stakePoolPledgeInfluence: TupleNumberFromString,
  monetaryExpansion: TupleNumberFromString,
  treasuryExpansion: TupleNumberFromString,
  minStakePoolCost: S.Struct({ ada: LovelaceAsset }),
  minUtxoDepositConstant: S.Struct({ ada: LovelaceAsset }),
  minUtxoDepositCoefficient: S.Number,
  plutusCostModels: S.Struct({
    "plutus:v1": S.Array(S.Number),
    "plutus:v2": S.Array(S.Number),
    "plutus:v3": S.Array(S.Number)
  }),
  scriptExecutionPrices: S.Struct({
    memory: TupleNumberFromString,
    cpu: TupleNumberFromString
  }),
  maxExecutionUnitsPerTransaction: S.Struct({
    memory: S.Number,
    cpu: S.Number
  }),
  maxExecutionUnitsPerBlock: S.Struct({ memory: S.Number, cpu: S.Number }),
  maxValueSize: S.Struct({ bytes: S.Number }),
  collateralPercentage: S.Number,
  maxCollateralInputs: S.Number,
  version: S.Struct({ major: S.Number, minor: S.Number })
});
var Delegation = S.NullOr(
  S.Record(
    S.String,
    S.Struct({
      delegate: S.Struct({ id: S.String }),
      rewards: S.Struct({ ada: S.Struct({ lovelace: S.Number }) }),
      deposit: S.Struct({ ada: S.Struct({ lovelace: S.Number }) })
    })
  )
);
var RedeemerSchema = S.Struct({
  validator: S.Struct({
    purpose: S.Literal(
      "spend",
      "mint",
      "publish",
      "withdraw",
      "vote",
      "propose"
    ),
    index: S.Int
  }),
  budget: S.Struct({
    memory: S.Int,
    cpu: S.Int
  })
});
var toOgmiosUTxOs = (utxos) => {
  const toOgmiosScript = (scriptRef) => {
    if (scriptRef) {
      switch (scriptRef.type) {
        case "PlutusV1":
          return { language: "plutus:v1", cbor: scriptRef.script };
        case "PlutusV2":
          return { language: "plutus:v2", cbor: scriptRef.script };
        case "PlutusV3":
          return { language: "plutus:v3", cbor: scriptRef.script };
        default:
          return null;
      }
    }
  };
  const toOgmiosAssets = (assets) => {
    const newAssets = {};
    Object.entries(assets).forEach(([unit, amount]) => {
      if (unit == "lovelace") return;
      const { policyId, assetName } = fromUnit(unit);
      if (!newAssets[policyId]) {
        newAssets[policyId] = {};
      }
      return newAssets[policyId][assetName ? assetName : ""] = Number(amount);
    });
    return newAssets;
  };
  return (utxos || []).map(
    (utxo) => ({
      transaction: {
        id: utxo.txHash
      },
      index: utxo.outputIndex,
      address: utxo.address,
      value: {
        ada: { lovelace: Number(utxo.assets["lovelace"]) },
        ...toOgmiosAssets(utxo.assets)
      },
      datumHash: utxo.datumHash,
      datum: utxo.datum,
      script: toOgmiosScript(utxo.scriptRef)
    })
  );
};

// src/internal/kupo.ts
import * as S2 from "@effect/schema/Schema";
var ValueSchema = S2.Struct({
  coins: S2.Number,
  assets: S2.Record(S2.String, S2.Number)
});
var UTxOSchema = S2.Struct({
  transaction_index: S2.Number,
  transaction_id: S2.String,
  output_index: S2.Number,
  address: S2.String,
  value: ValueSchema,
  datum_hash: S2.NullOr(S2.String),
  datum_type: S2.optional(S2.Literal("hash", "inline")),
  script_hash: S2.NullOr(S2.String),
  created_at: S2.Struct({
    slot_no: S2.Number,
    header_hash: S2.String
  }),
  spent_at: S2.NullOr(
    S2.Struct({
      slot_no: S2.Number,
      header_hash: S2.String
    })
  )
});
var ScriptSchema = S2.NullOr(
  S2.Struct({
    language: S2.Literal("native", "plutus:v1", "plutus:v2", "plutus:v3"),
    script: S2.String
  })
);
var DatumSchema = S2.NullOr(S2.Struct({ datum: S2.String }));
var DelegationSchema = S2.NullOr(
  S2.Record(
    S2.String,
    S2.Struct({
      delegate: S2.Struct({ id: S2.String }),
      rewards: S2.Struct({ ada: S2.Struct({ lovelace: S2.Number }) }),
      deposit: S2.Struct({ ada: S2.Struct({ lovelace: S2.Number }) })
    })
  )
);

// src/kupmios.ts
var KupmiosError = class extends Data.TaggedError("KupmiosError") {
  get message() {
    return `${JSON.stringify(this.cause)}`;
  }
};
var Kupmios = class {
  kupoUrl;
  ogmiosUrl;
  /**
   * @param kupoUrl: http(s)://localhost:1442
   * @param ogmiosUrl: http(s)://localhost:1337
   */
  constructor(kupoUrl, ogmiosUrl) {
    this.kupoUrl = kupoUrl;
    this.ogmiosUrl = ogmiosUrl;
  }
  async getProtocolParameters() {
    const data = {
      jsonrpc: "2.0",
      method: "queryLedgerState/protocolParameters",
      params: {},
      id: null
    };
    const schema = JSONRPCSchema(ProtocolParametersSchema);
    const program = fetchOgmiosParse(this.ogmiosUrl, data, schema).pipe(
      Effect.flatMap(
        (response) => "error" in response ? Effect.fail(response) : Effect.succeed(response.result)
      ),
      Effect.timeout(1e4),
      Effect.catchAll((cause) => new KupmiosError({ cause }))
    );
    const result = await Effect.runPromise(program);
    return toProtocolParameters(result);
  }
  async getUtxos(addressOrCredential) {
    const isAddress = typeof addressOrCredential === "string";
    const queryPredicate = isAddress ? addressOrCredential : addressOrCredential.hash;
    const pattern = `${this.kupoUrl}/matches/${queryPredicate}${isAddress ? "" : "/*"}?unspent`;
    const schema = S3.Array(UTxOSchema);
    const program = fetchKupoParse(pattern, schema).pipe(
      Effect.flatMap((u) => kupmiosUtxosToUtxos(this.kupoUrl, u)),
      Effect.timeout(1e4),
      Effect.catchAll((cause) => new KupmiosError({ cause }))
    );
    const utxos = await Effect.runPromise(program);
    return utxos;
  }
  async getUtxosWithUnit(addressOrCredential, unit) {
    const isAddress = typeof addressOrCredential === "string";
    const queryPredicate = isAddress ? addressOrCredential : addressOrCredential.hash;
    const { policyId, assetName } = fromUnit2(unit);
    const pattern = `${this.kupoUrl}/matches/${queryPredicate}${isAddress ? "" : "/*"}?unspent&policy_id=${policyId}${assetName ? `&asset_name=${assetName}` : ""}`;
    const schema = S3.Array(UTxOSchema);
    const program = fetchKupoParse(pattern, schema).pipe(
      Effect.flatMap((u) => kupmiosUtxosToUtxos(this.kupoUrl, u)),
      Effect.timeout(1e4),
      Effect.catchAll((cause) => new KupmiosError({ cause }))
    );
    const utxos = await Effect.runPromise(program);
    return utxos;
  }
  async getUtxoByUnit(unit) {
    const { policyId, assetName } = fromUnit2(unit);
    const pattern = `${this.kupoUrl}/matches/${policyId}.${assetName ? `${assetName}` : "*"}?unspent`;
    const schema = S3.Array(UTxOSchema);
    const program = fetchKupoParse(pattern, schema).pipe(
      Effect.flatMap((u) => kupmiosUtxosToUtxos(this.kupoUrl, u)),
      Effect.timeout(1e4),
      Effect.catchAll((cause) => new KupmiosError({ cause }))
    );
    const utxos = await Effect.runPromise(program);
    if (utxos.length > 1) {
      throw new Error("Unit needs to be an NFT or only held by one address.");
    }
    return utxos[0];
  }
  async getUtxosByOutRef(outRefs) {
    const queryHashes = [
      ...new Set(outRefs.map((outRef) => outRef.txHash))
    ];
    const mkPattern = (txHash) => `${this.kupoUrl}/matches/*@${txHash}?unspent`;
    const schema = S3.Array(UTxOSchema);
    const program = Effect.forEach(
      queryHashes,
      (txHash) => fetchKupoParse(mkPattern(txHash), schema).pipe(
        Effect.flatMap((u) => kupmiosUtxosToUtxos(this.kupoUrl, u)),
        Effect.timeout(1e4),
        Effect.catchAll((cause) => new KupmiosError({ cause }))
      )
    );
    const utxos = await Effect.runPromise(program);
    return _Array.flatten(utxos).filter(
      (utxo) => outRefs.some(
        (outRef) => utxo.txHash === outRef.txHash && utxo.outputIndex === outRef.outputIndex
      )
    );
  }
  async getDelegation(rewardAddress) {
    const data = {
      jsonrpc: "2.0",
      method: "queryLedgerState/rewardAccountSummaries",
      params: { keys: [rewardAddress] },
      id: null
    };
    const schema = JSONRPCSchema(Delegation);
    const program = fetchOgmiosParse(this.ogmiosUrl, data, schema).pipe(
      Effect.flatMap(
        (response) => "error" in response ? Effect.fail(response) : Effect.succeed(response.result)
      ),
      Effect.timeout(1e4),
      Effect.catchAll((cause) => new KupmiosError({ cause }))
    );
    const result = await Effect.runPromise(program);
    const delegation = result ? Object.values(result)[0] : null;
    return {
      poolId: delegation?.delegate?.id || null,
      rewards: BigInt(delegation?.rewards?.ada?.lovelace || 0)
    };
  }
  async getDatum(datumHash) {
    const pattern = `${this.kupoUrl}/datums/${datumHash}`;
    const schema = DatumSchema;
    const program = fetchKupoParse(pattern, schema).pipe(
      Effect.timeout(1e4),
      Effect.flatMap(Effect.fromNullable),
      Effect.catchAll((cause) => new KupmiosError({ cause }))
    );
    const result = await Effect.runPromise(program);
    return result.datum;
  }
  async awaitTx(txHash, checkInterval = 2e4) {
    const pattern = `${this.kupoUrl}/matches/*@${txHash}`;
    const schema = S3.Array(UTxOSchema).annotations({
      identifier: "Array<KupmiosSchema.KupoUTxO>"
    });
    const program = fetchKupoParse(pattern, schema).pipe(
      Effect.repeat({
        schedule: Schedule.exponential(checkInterval),
        until: (result) => result.length > 0
      }),
      Effect.timeout(16e4),
      Effect.catchAll((cause) => new KupmiosError({ cause })),
      Effect.as(true)
    );
    return await Effect.runPromise(program);
  }
  async submitTx(cbor) {
    const data = {
      jsonrpc: "2.0",
      method: "submitTransaction",
      params: {
        transaction: { cbor }
      },
      id: null
    };
    const schema = JSONRPCSchema(
      S3.Struct({
        transaction: S3.Struct({
          id: S3.String
        })
      })
    );
    const program = fetchOgmiosParse(this.ogmiosUrl, data, schema).pipe(
      Effect.flatMap(
        (response) => "error" in response ? Effect.fail(response) : Effect.succeed(response)
      ),
      Effect.timeout(1e4),
      Effect.catchAll((cause) => new KupmiosError({ cause }))
    );
    const { result } = await Effect.runPromise(program);
    return result.transaction.id;
  }
  async evaluateTx(tx, additionalUTxOs) {
    const data = {
      jsonrpc: "2.0",
      method: "evaluateTransaction",
      params: {
        transaction: { cbor: tx },
        additionalUtxo: toOgmiosUTxOs(additionalUTxOs)
      },
      id: null
    };
    const schema = JSONRPCSchema(S3.Array(RedeemerSchema));
    const program = fetchOgmiosParse(this.ogmiosUrl, data, schema).pipe(
      Effect.flatMap(
        (response) => "error" in response ? Effect.fail(response) : Effect.succeed(response.result)
      ),
      Effect.timeout(1e4),
      Effect.catchAll((cause) => new KupmiosError({ cause }))
    );
    const result = await Effect.runPromise(program);
    const evalRedeemers = result.map((item) => ({
      ex_units: {
        mem: item.budget.memory,
        steps: item.budget.cpu
      },
      redeemer_index: item.validator.index,
      redeemer_tag: item.validator.purpose
    }));
    return evalRedeemers;
  }
};
var getDatumEffect = (kupoUrl, datum_type, datum_hash) => Effect.gen(function* () {
  if (datum_type === "inline" && datum_hash) {
    const pattern = `${kupoUrl}/datums/${datum_hash}`;
    const schema = DatumSchema;
    return yield* fetchKupoParse(pattern, schema).pipe(
      Effect.flatMap(Effect.fromNullable),
      Effect.map((result) => result.datum),
      Effect.retry(
        Schedule.compose(Schedule.exponential(50), Schedule.recurs(5))
      ),
      Effect.timeout(5e3)
    );
  } else return void 0;
});
var getScriptEffect = (kupoUrl, script_hash) => Effect.gen(function* () {
  if (script_hash) {
    const pattern = `${kupoUrl}/scripts/${script_hash}`;
    const schema = ScriptSchema;
    return yield* pipe2(
      fetchKupoParse(pattern, schema),
      Effect.flatMap(Effect.fromNullable),
      Effect.retry(
        Schedule.compose(Schedule.exponential(50), Schedule.recurs(5))
      ),
      Effect.timeout(5e3),
      Effect.map(({ language, script }) => {
        switch (language) {
          case "native":
            return {
              type: "Native",
              script
            };
          case "plutus:v1":
            return {
              type: "PlutusV1",
              script: applyDoubleCborEncoding2(script)
            };
          case "plutus:v2":
            return {
              type: "PlutusV2",
              script: applyDoubleCborEncoding2(script)
            };
          case "plutus:v3":
            return {
              type: "PlutusV3",
              script: applyDoubleCborEncoding2(script)
            };
        }
      })
    );
  } else return void 0;
});
var toAssets = (value) => {
  const assets = { lovelace: BigInt(value.coins) };
  for (const unit of Object.keys(value.assets)) {
    assets[unit.replace(".", "")] = BigInt(value.assets[unit]);
  }
  return assets;
};
var toProtocolParameters = (result) => {
  return {
    minFeeA: result.minFeeCoefficient,
    minFeeB: result.minFeeConstant.ada.lovelace,
    maxTxSize: result.maxTransactionSize.bytes,
    maxValSize: result.maxValueSize.bytes,
    keyDeposit: BigInt(result.stakeCredentialDeposit.ada.lovelace),
    poolDeposit: BigInt(result.stakePoolDeposit.ada.lovelace),
    drepDeposit: BigInt(result.delegateRepresentativeDeposit.ada.lovelace),
    govActionDeposit: BigInt(result.governanceActionDeposit.ada.lovelace),
    priceMem: result.scriptExecutionPrices.memory[0] / result.scriptExecutionPrices.memory[1],
    priceStep: result.scriptExecutionPrices.cpu[0] / result.scriptExecutionPrices.cpu[1],
    maxTxExMem: BigInt(result.maxExecutionUnitsPerTransaction.memory),
    maxTxExSteps: BigInt(result.maxExecutionUnitsPerTransaction.cpu),
    // NOTE: coinsPerUtxoByte is now called utxoCostPerByte:
    // https://github.com/IntersectMBO/cardano-node/pull/4141
    // Ogmios v6.x calls it minUtxoDepositCoefficient according to the following
    // documentation from its protocol parameters data model:
    // https://github.com/CardanoSolutions/ogmios/blob/master/architectural-decisions/accepted/017-api-version-6-major-rewrite.md#protocol-parameters
    coinsPerUtxoByte: BigInt(result.minUtxoDepositCoefficient),
    collateralPercentage: result.collateralPercentage,
    maxCollateralInputs: result.maxCollateralInputs,
    minFeeRefScriptCostPerByte: result.minFeeReferenceScripts.base,
    costModels: {
      PlutusV1: Object.fromEntries(
        result.plutusCostModels["plutus:v1"].map((value, index) => [
          index.toString(),
          value
        ])
      ),
      PlutusV2: Object.fromEntries(
        result.plutusCostModels["plutus:v2"].map((value, index) => [
          index.toString(),
          value
        ])
      ),
      PlutusV3: Object.fromEntries(
        result.plutusCostModels["plutus:v3"].map((value, index) => [
          index.toString(),
          value
        ])
      )
    }
  };
};
var fetchOgmiosParse = (url, data, schema) => pipe2(
  HttpClientRequest.post(url),
  HttpClientRequest.jsonBody(data),
  Effect.flatMap(HttpClient.fetch),
  HttpClientResponse.json,
  Effect.flatMap(S3.decodeUnknown(schema)),
  Effect.catchTag(
    "ParseError",
    (e) => Effect.fail(ArrayFormatter.formatErrorSync(e))
  )
  // Effect.scoped
);
var fetchKupoParse = (url, schema) => pipe2(
  HttpClientRequest.get(url),
  HttpClient.fetchOk,
  HttpClientResponse.json,
  Effect.flatMap(S3.decodeUnknown(schema, { onExcessProperty: "error" })),
  Effect.catchTag(
    "ParseError",
    (e) => Effect.fail(ArrayFormatter.formatErrorSync(e))
  )
  // Effect.scoped
);
var kupmiosUtxosToUtxos = (kupoURL, utxos) => Effect.forEach(
  utxos,
  (utxo) => {
    return pipe2(
      Effect.all([
        getDatumEffect(kupoURL, utxo.datum_type, utxo.datum_hash),
        getScriptEffect(kupoURL, utxo.script_hash)
      ]),
      Effect.map(
        ([datum, script]) => ({
          txHash: utxo.transaction_id,
          outputIndex: utxo.output_index,
          address: utxo.address,
          assets: toAssets(utxo.value),
          datumHash: utxo.datum_type === "hash" ? utxo.datum_hash : void 0,
          datum,
          scriptRef: script
        })
      )
    );
  },
  { concurrency: "unbounded" }
);

// src/emulator.ts
import {
  fromCMLRedeemerTag,
  generateSeedPhrase,
  PROTOCOL_PARAMETERS_DEFAULT
} from "@lucid-evolution/utils";
import { coreToUtxo, getAddressDetails } from "@lucid-evolution/utils";
import { fromHex as fromHex2 } from "@lucid-evolution/core-utils";
import { walletFromSeed } from "@lucid-evolution/wallet";
async function generateEmulatorAccountFrommPrivateKey(assets) {
  const privateKey = CML.PrivateKey.generate_ed25519().to_bech32();
  const priv = CML.PrivateKey.from_bech32(privateKey);
  const pubKeyHash = priv.to_public().hash();
  const address = CML.EnterpriseAddress.new(
    0,
    CML.Credential.new_pub_key(pubKeyHash)
  ).to_address().to_bech32(void 0);
  return {
    seedPhrase: "",
    address,
    assets,
    privateKey
  };
}
function generateEmulatorAccount(assets) {
  const seedPhrase = generateSeedPhrase();
  return {
    seedPhrase,
    address: walletFromSeed(seedPhrase, {
      addressType: "Base",
      accountIndex: 0,
      network: "Custom"
    }).address,
    assets,
    privateKey: ""
  };
}
var Emulator = class {
  ledger;
  mempool = {};
  /**
   * Only stake key registrations/delegations and rewards are tracked.
   * Other certificates are not tracked.
   */
  chain = {};
  blockHeight;
  slot;
  time;
  protocolParameters;
  datumTable = {};
  constructor(accounts, protocolParameters = PROTOCOL_PARAMETERS_DEFAULT) {
    const GENESIS_HASH = "00".repeat(32);
    this.blockHeight = 0;
    this.slot = 0;
    this.time = Date.now();
    this.ledger = {};
    accounts.forEach(({ address, assets, outputData }, index) => {
      if ([outputData?.hash, outputData?.asHash, outputData?.inline].filter(
        (b) => b
      ).length > 1) {
        throw new Error(
          "Not allowed to set hash, asHash and inline at the same time."
        );
      }
      this.ledger[GENESIS_HASH + index] = {
        utxo: {
          txHash: GENESIS_HASH,
          outputIndex: index,
          address,
          assets,
          datumHash: outputData?.asHash ? CML.hash_plutus_data(
            CML.PlutusData.from_cbor_hex(outputData.asHash)
          ).to_hex() : outputData?.hash,
          datum: outputData?.inline,
          scriptRef: outputData?.scriptRef
        },
        spent: false
      };
    });
    this.protocolParameters = protocolParameters;
  }
  now() {
    return this.time;
  }
  awaitSlot(length = 1) {
    this.slot += length;
    this.time += length * 1e3;
    const currentHeight = this.blockHeight;
    this.blockHeight = Math.floor(this.slot / 20);
    if (this.blockHeight > currentHeight) {
      for (const [outRef, { utxo, spent }] of Object.entries(this.mempool)) {
        this.ledger[outRef] = { utxo, spent };
      }
      for (const [outRef, { spent }] of Object.entries(this.ledger)) {
        if (spent) delete this.ledger[outRef];
      }
      this.mempool = {};
    }
  }
  awaitBlock(height = 1) {
    this.blockHeight += height;
    this.slot += height * 20;
    this.time += height * 20 * 1e3;
    for (const [outRef, { utxo, spent }] of Object.entries(this.mempool)) {
      this.ledger[outRef] = { utxo, spent };
    }
    for (const [outRef, { spent }] of Object.entries(this.ledger)) {
      if (spent) delete this.ledger[outRef];
    }
    this.mempool = {};
  }
  getUtxos(addressOrCredential) {
    const utxos = Object.values(this.ledger).flatMap(({ utxo }) => {
      if (typeof addressOrCredential === "string") {
        return addressOrCredential === utxo.address ? utxo : [];
      } else {
        const { paymentCredential } = getAddressDetails(utxo.address);
        return paymentCredential?.hash === addressOrCredential.hash ? utxo : [];
      }
    });
    return Promise.resolve(utxos);
  }
  getProtocolParameters() {
    return Promise.resolve(this.protocolParameters);
  }
  getDatum(datumHash) {
    return Promise.resolve(this.datumTable[datumHash]);
  }
  getUtxosWithUnit(addressOrCredential, unit) {
    const utxos = Object.values(this.ledger).flatMap(({ utxo }) => {
      if (typeof addressOrCredential === "string") {
        return addressOrCredential === utxo.address && utxo.assets[unit] > 0n ? utxo : [];
      } else {
        const { paymentCredential } = getAddressDetails(utxo.address);
        return paymentCredential?.hash === addressOrCredential.hash && utxo.assets[unit] > 0n ? utxo : [];
      }
    });
    return Promise.resolve(utxos);
  }
  getUtxosByOutRef(outRefs) {
    return Promise.resolve(
      outRefs.flatMap(
        (outRef) => this.ledger[outRef.txHash + outRef.outputIndex]?.utxo || []
      )
    );
  }
  getUtxoByUnit(unit) {
    const utxos = Object.values(this.ledger).flatMap(
      ({ utxo }) => utxo.assets[unit] > 0n ? utxo : []
    );
    if (utxos.length > 1) {
      throw new Error("Unit needs to be an NFT or only held by one address.");
    }
    return Promise.resolve(utxos[0]);
  }
  getDelegation(rewardAddress) {
    return Promise.resolve({
      poolId: this.chain[rewardAddress]?.delegation?.poolId || null,
      rewards: this.chain[rewardAddress]?.delegation?.rewards || 0n
    });
  }
  awaitTx(txHash) {
    if (this.mempool[txHash + 0]) {
      this.awaitBlock();
      return Promise.resolve(true);
    }
    return Promise.resolve(true);
  }
  /**
   * Emulates the behaviour of the reward distribution at epoch boundaries.
   * Stake keys need to be registered and delegated like on a real chain in order to receive rewards.
   */
  distributeRewards(rewards) {
    for (const [
      rewardAddress,
      { registeredStake, delegation }
    ] of Object.entries(this.chain)) {
      if (registeredStake && delegation.poolId) {
        this.chain[rewardAddress] = {
          registeredStake,
          delegation: {
            poolId: delegation.poolId,
            rewards: delegation.rewards += rewards
          }
        };
      }
    }
    this.awaitBlock();
  }
  submitTx(tx) {
    const desTx = CML.Transaction.from_cbor_hex(tx);
    const body = desTx.body();
    const witnesses = desTx.witness_set();
    const datums = witnesses.plutus_datums();
    const txHash = CML.hash_transaction(body).to_hex();
    const lowerBound = body.validity_interval_start() ? parseInt(body.validity_interval_start().toString()) : null;
    const upperBound = body.ttl() ? parseInt(body.ttl().toString()) : null;
    if (Number.isInteger(lowerBound) && this.slot < lowerBound) {
      throw new Error(
        `Lower bound (${lowerBound}) not in slot range (${this.slot}).`
      );
    }
    if (Number.isInteger(upperBound) && this.slot > upperBound) {
      throw new Error(
        `Upper bound (${upperBound}) not in slot range (${this.slot}).`
      );
    }
    const datumTable = (() => {
      const table = {};
      for (let i = 0; i < (datums?.len() || 0); i++) {
        const datum = datums.get(i);
        const datumHash = CML.hash_plutus_data(datum).to_hex();
        table[datumHash] = datum.to_cbor_hex();
      }
      return table;
    })();
    const consumedHashes = /* @__PURE__ */ new Set();
    const keyHashes = (() => {
      const keyHashes2 = [];
      for (let i = 0; i < (witnesses.vkeywitnesses()?.len() || 0); i++) {
        const witness = witnesses.vkeywitnesses().get(i);
        const publicKey = witness.vkey();
        const keyHash = publicKey.hash().to_hex();
        if (!publicKey.verify(fromHex2(txHash), witness.ed25519_signature())) {
          throw new Error(`Invalid vkey witness. Key hash: ${keyHash}`);
        }
        keyHashes2.push(keyHash);
      }
      return keyHashes2;
    })();
    const edKeyHashes = CML.Ed25519KeyHashList.new();
    keyHashes.forEach(
      (keyHash) => edKeyHashes.add(CML.Ed25519KeyHash.from_hex(keyHash))
    );
    const nativeHashes = (() => {
      const scriptHashes = [];
      for (let i = 0; i < (witnesses.native_scripts()?.len() || 0); i++) {
        const witness = witnesses.native_scripts().get(i);
        const scriptHash = witness.hash().to_hex();
        if (!witness.verify(
          Number.isInteger(lowerBound) ? CML.BigInteger.from_str(lowerBound.toString()).to_js_value() : void 0,
          Number.isInteger(upperBound) ? CML.BigInteger.from_str(upperBound.toString()).to_js_value() : void 0,
          edKeyHashes
        )) {
          throw new Error(
            `Invalid native script witness. Script hash: ${scriptHash}`
          );
        }
        for (let i2 = 0; i2 < witness.get_required_signers().len(); i2++) {
          const keyHash = witness.get_required_signers().get(i2).to_hex();
          consumedHashes.add(keyHash);
        }
        scriptHashes.push(scriptHash);
      }
      return scriptHashes;
    })();
    const nativeHashesOptional = {};
    const plutusHashesOptional = [];
    const plutusHashes = (() => {
      const scriptHashes = [];
      for (let i = 0; i < (witnesses.plutus_v1_scripts()?.len() || 0); i++) {
        const script = witnesses.plutus_v1_scripts().get(i);
        const scriptHash = script.hash().to_hex();
        scriptHashes.push(scriptHash);
      }
      for (let i = 0; i < (witnesses.plutus_v2_scripts()?.len() || 0); i++) {
        const script = witnesses.plutus_v2_scripts().get(i);
        const scriptHash = script.hash().to_hex();
        scriptHashes.push(scriptHash);
      }
      for (let i = 0; i < (witnesses.plutus_v3_scripts()?.len() || 0); i++) {
        const script = witnesses.plutus_v3_scripts().get(i);
        const scriptHash = script.hash().to_hex();
        scriptHashes.push(scriptHash);
      }
      return scriptHashes;
    })();
    const inputs = body.inputs();
    const resolvedInputs = [];
    for (let i = 0; i < inputs.len(); i++) {
      const input = inputs.get(i);
      const outRef = input.transaction_id().to_hex() + input.index().toString();
      const entryLedger = this.ledger[outRef];
      const { entry, type } = !entryLedger ? { entry: this.mempool[outRef], type: "Mempool" } : { entry: entryLedger, type: "Ledger" };
      if (!entry || entry.spent) {
        throw new Error(
          `Could not spend UTxO: ${JSON.stringify({
            txHash: entry?.utxo.txHash,
            outputIndex: entry?.utxo.outputIndex
          })}
It does not exist or was already spent.`
        );
      }
      const scriptRef = entry.utxo.scriptRef;
      if (scriptRef) {
        switch (scriptRef.type) {
          case "Native": {
            const script = CML.NativeScript.from_cbor_bytes(
              fromHex2(scriptRef.script)
            );
            nativeHashesOptional[script.hash().to_hex()] = script;
            break;
          }
          case "PlutusV1": {
            const script = CML.PlutusScript.from_v1(
              CML.PlutusV1Script.from_cbor_bytes(fromHex2(scriptRef.script))
            );
            plutusHashesOptional.push(script.hash().to_hex());
            break;
          }
          case "PlutusV2": {
            const script = CML.PlutusScript.from_v2(
              CML.PlutusV2Script.from_cbor_bytes(fromHex2(scriptRef.script))
            );
            plutusHashesOptional.push(script.hash().to_hex());
            break;
          }
          case "PlutusV3": {
            const script = CML.PlutusScript.from_v3(
              CML.PlutusV3Script.from_cbor_bytes(fromHex2(scriptRef.script))
            );
            plutusHashesOptional.push(script.hash().to_hex());
            break;
          }
        }
      }
      if (entry.utxo.datumHash) consumedHashes.add(entry.utxo.datumHash);
      resolvedInputs.push({ entry, type });
    }
    for (let i = 0; i < (body.reference_inputs()?.len() || 0); i++) {
      const input = body.reference_inputs().get(i);
      const outRef = input.transaction_id().to_hex() + input.index().toString();
      const entry = this.ledger[outRef] || this.mempool[outRef];
      if (!entry || entry.spent) {
        throw new Error(
          `Could not read UTxO: ${JSON.stringify({
            txHash: entry?.utxo.txHash,
            outputIndex: entry?.utxo.outputIndex
          })}
It does not exist or was already spent.`
        );
      }
      const scriptRef = entry.utxo.scriptRef;
      if (scriptRef) {
        switch (scriptRef.type) {
          case "Native": {
            const script = CML.NativeScript.from_cbor_bytes(
              fromHex2(scriptRef.script)
            );
            nativeHashesOptional[script.hash().to_hex()] = script;
            break;
          }
          case "PlutusV1": {
            const script = CML.PlutusScript.from_v1(
              CML.PlutusV1Script.from_cbor_bytes(fromHex2(scriptRef.script))
            );
            plutusHashesOptional.push(script.hash().to_hex());
            break;
          }
          case "PlutusV2": {
            const script = CML.PlutusScript.from_v2(
              CML.PlutusV2Script.from_cbor_bytes(fromHex2(scriptRef.script))
            );
            plutusHashesOptional.push(script.hash().to_hex());
            break;
          }
          case "PlutusV3": {
            const script = CML.PlutusScript.from_v3(
              CML.PlutusV3Script.from_cbor_bytes(fromHex2(scriptRef.script))
            );
            plutusHashesOptional.push(script.hash().to_hex());
            break;
          }
        }
      }
      if (entry.utxo.datumHash) consumedHashes.add(entry.utxo.datumHash);
    }
    const redeemers = (() => {
      const tagMap = {
        0: "Spend",
        1: "Mint",
        2: "Cert",
        3: "Reward",
        4: "Proposing",
        5: "Voting"
      };
      const collected = [];
      const redeemers2 = witnesses.redeemers();
      const arrLegacyRedeemer = redeemers2?.as_arr_legacy_redeemer();
      if (arrLegacyRedeemer) {
        for (let i = 0; i < (arrLegacyRedeemer.len() || 0); i++) {
          const redeemer = arrLegacyRedeemer.get(i);
          collected.push({
            tag: tagMap[redeemer.tag()],
            index: Number(redeemer.index())
          });
        }
      }
      const mapRedeemerKeyToRedeemerVal = redeemers2?.as_map_redeemer_key_to_redeemer_val();
      if (mapRedeemerKeyToRedeemerVal) {
        const keys = mapRedeemerKeyToRedeemerVal.keys();
        for (let i = 0; i < (keys.len() || 0); i++) {
          const key = keys.get(i);
          collected.push({
            tag: tagMap[key.tag()],
            index: Number(key.index())
          });
        }
      }
      return collected;
    })();
    function checkAndConsumeHash(credential, tag, index) {
      switch (credential.type) {
        case "Key": {
          if (!keyHashes.includes(credential.hash)) {
            throw new Error(
              `Missing vkey witness. Key hash: ${credential.hash}`
            );
          }
          consumedHashes.add(credential.hash);
          break;
        }
        case "Script": {
          if (nativeHashes.includes(credential.hash)) {
            consumedHashes.add(credential.hash);
            break;
          } else if (nativeHashesOptional[credential.hash]) {
            if (!nativeHashesOptional[credential.hash].verify(
              Number.isInteger(lowerBound) ? CML.BigInteger.from_str(
                lowerBound.toString()
              ).to_js_value() : void 0,
              Number.isInteger(upperBound) ? CML.BigInteger.from_str(
                upperBound.toString()
              ).to_js_value() : void 0,
              edKeyHashes
            )) {
              throw new Error(
                `Invalid native script witness. Script hash: ${credential.hash}`
              );
            }
            break;
          } else if (plutusHashes.includes(credential.hash) || plutusHashesOptional.includes(credential.hash)) {
            if (redeemers.find(
              (redeemer) => redeemer.tag === tag && redeemer.index === index
            )) {
              consumedHashes.add(credential.hash);
              break;
            }
          }
          throw new Error(
            `Missing script witness. Script hash: ${credential.hash}`
          );
        }
      }
    }
    for (let i = 0; i < (body.collateral_inputs()?.len() || 0); i++) {
      const input = body.collateral_inputs().get(i);
      const outRef = input.transaction_id().to_hex() + input.index().toString();
      const entry = this.ledger[outRef] || this.mempool[outRef];
      if (!entry || entry.spent) {
        throw new Error(
          `Could not read UTxO: ${JSON.stringify({
            txHash: entry?.utxo.txHash,
            outputIndex: entry?.utxo.outputIndex
          })}
It does not exist or was already spent.`
        );
      }
      const { paymentCredential } = getAddressDetails(entry.utxo.address);
      if (paymentCredential?.type === "Script") {
        throw new Error("Collateral inputs can only contain vkeys.");
      }
      checkAndConsumeHash(paymentCredential, null, null);
    }
    for (let i = 0; i < (body.required_signers()?.len() || 0); i++) {
      const signer = body.required_signers().get(i);
      checkAndConsumeHash({ type: "Key", hash: signer.to_hex() }, null, null);
    }
    for (let index = 0; index < (body.mint()?.keys().len() || 0); index++) {
      const policyId = body.mint().keys().get(index).to_hex();
      checkAndConsumeHash({ type: "Script", hash: policyId }, "Mint", index);
    }
    const withdrawalRequests = [];
    for (let index = 0; index < (body.withdrawals()?.keys().len() || 0); index++) {
      const rawAddress = body.withdrawals().keys().get(index);
      const withdrawal = BigInt(
        body.withdrawals().get(rawAddress).toString()
      );
      const rewardAddress = rawAddress.to_address().to_bech32(void 0);
      const { stakeCredential } = getAddressDetails(rewardAddress);
      checkAndConsumeHash(stakeCredential, "Reward", index);
      if (this.chain[rewardAddress]?.delegation.rewards !== withdrawal) {
        throw new Error(
          "Withdrawal amount doesn't match actual reward balance."
        );
      }
      withdrawalRequests.push({ rewardAddress, withdrawal });
    }
    const certRequests = [];
    for (let index = 0; index < (body.certs()?.len() || 0); index++) {
      const cert = body.certs().get(index);
      switch (cert.kind()) {
        case 0: {
          const registration = cert.as_stake_registration();
          const rewardAddress = CML.RewardAddress.new(
            CML.NetworkInfo.testnet().network_id(),
            registration.stake_credential()
          ).to_address().to_bech32(void 0);
          if (this.chain[rewardAddress]?.registeredStake) {
            throw new Error(
              `Stake key is already registered. Reward address: ${rewardAddress}`
            );
          }
          certRequests.push({ type: "Registration", rewardAddress });
          break;
        }
        case 1: {
          const deregistration = cert.as_stake_deregistration();
          const rewardAddress = CML.RewardAddress.new(
            CML.NetworkInfo.testnet().network_id(),
            deregistration.stake_credential()
          ).to_address().to_bech32(void 0);
          const { stakeCredential } = getAddressDetails(rewardAddress);
          checkAndConsumeHash(stakeCredential, "Cert", index);
          if (!this.chain[rewardAddress]?.registeredStake) {
            throw new Error(
              `Stake key is already deregistered. Reward address: ${rewardAddress}`
            );
          }
          certRequests.push({ type: "Deregistration", rewardAddress });
          break;
        }
        case 2: {
          const delegation = cert.as_stake_delegation();
          const rewardAddress = CML.RewardAddress.new(
            CML.NetworkInfo.testnet().network_id(),
            delegation.stake_credential()
          ).to_address().to_bech32(void 0);
          const poolId = delegation.pool().to_bech32("pool");
          const { stakeCredential } = getAddressDetails(rewardAddress);
          checkAndConsumeHash(stakeCredential, "Cert", index);
          if (!this.chain[rewardAddress]?.registeredStake && !certRequests.find(
            (request) => request.type === "Registration" && request.rewardAddress === rewardAddress
          )) {
            throw new Error(
              `Stake key is not registered. Reward address: ${rewardAddress}`
            );
          }
          certRequests.push({ type: "Delegation", rewardAddress, poolId });
          break;
        }
      }
    }
    resolvedInputs.forEach(({ entry: { utxo } }, index) => {
      const { paymentCredential } = getAddressDetails(utxo.address);
      checkAndConsumeHash(paymentCredential, "Spend", index);
    });
    const outputs = (() => {
      const collected = [];
      for (let i = 0; i < body.outputs().len(); i++) {
        const output = body.outputs().get(i);
        const unspentOutput = CML.TransactionUnspentOutput.new(
          CML.TransactionInput.new(
            CML.TransactionHash.from_hex(txHash),
            CML.BigInteger.from_str(i.toString()).to_js_value()
          ),
          output
        );
        const utxo = coreToUtxo(unspentOutput);
        if (utxo.datumHash) consumedHashes.add(utxo.datumHash);
        collected.push({
          utxo,
          spent: false
        });
      }
      return collected;
    })();
    const [extraKeyHash] = keyHashes.filter(
      (keyHash) => !consumedHashes.has(keyHash)
    );
    if (extraKeyHash) {
      throw new Error(`Extraneous vkey witness. Key hash: ${extraKeyHash}`);
    }
    const [extraNativeHash] = nativeHashes.filter(
      (scriptHash) => !consumedHashes.has(scriptHash)
    );
    if (extraNativeHash) {
      throw new Error(
        `Extraneous native script. Script hash: ${extraNativeHash}`
      );
    }
    const [extraPlutusHash] = plutusHashes.filter(
      (scriptHash) => !consumedHashes.has(scriptHash)
    );
    if (extraPlutusHash) {
      throw new Error(
        `Extraneous plutus script. Script hash: ${extraPlutusHash}`
      );
    }
    const [extraDatumHash] = Object.keys(datumTable).filter(
      (datumHash) => !consumedHashes.has(datumHash)
    );
    if (extraDatumHash) {
      throw new Error(`Extraneous plutus data. Datum hash: ${extraDatumHash}`);
    }
    resolvedInputs.forEach(({ entry, type }) => {
      const outRef = entry.utxo.txHash + entry.utxo.outputIndex;
      entry.spent = true;
      if (type === "Ledger") this.ledger[outRef] = entry;
      else if (type === "Mempool") this.mempool[outRef] = entry;
    });
    withdrawalRequests.forEach(({ rewardAddress, withdrawal }) => {
      this.chain[rewardAddress].delegation.rewards -= withdrawal;
    });
    certRequests.forEach(({ type, rewardAddress, poolId }) => {
      switch (type) {
        case "Registration": {
          if (this.chain[rewardAddress]) {
            this.chain[rewardAddress].registeredStake = true;
          } else {
            this.chain[rewardAddress] = {
              registeredStake: true,
              delegation: { poolId: null, rewards: 0n }
            };
          }
          break;
        }
        case "Deregistration": {
          this.chain[rewardAddress].registeredStake = false;
          this.chain[rewardAddress].delegation.poolId = null;
          break;
        }
        case "Delegation": {
          this.chain[rewardAddress].delegation.poolId = poolId;
        }
      }
    });
    outputs.forEach(({ utxo, spent }) => {
      this.mempool[utxo.txHash + utxo.outputIndex] = {
        utxo,
        spent
      };
    });
    for (const [datumHash, datum] of Object.entries(datumTable)) {
      this.datumTable[datumHash] = datum;
    }
    return Promise.resolve(txHash);
  }
  async evaluateTx(tx, additionalUTxOs) {
    const desTx = CML.Transaction.from_cbor_hex(tx);
    const redeemers = desTx.witness_set().redeemers();
    if (!redeemers) {
      return [];
    }
    let evalRedeemers = [];
    const arrLegacyRedeemer = redeemers.as_arr_legacy_redeemer();
    if (arrLegacyRedeemer) {
      for (let i = 0; i < arrLegacyRedeemer.len(); i++) {
        const legacyRedeemer = arrLegacyRedeemer.get(i);
        evalRedeemers.push({
          ex_units: {
            mem: Number(legacyRedeemer.ex_units().mem()),
            steps: Number(legacyRedeemer.ex_units().steps())
          },
          redeemer_index: Number(legacyRedeemer.index()),
          redeemer_tag: fromCMLRedeemerTag(legacyRedeemer.tag())
        });
      }
      return evalRedeemers;
    }
    const mapRedeemerKeyToRedeemerVal = redeemers.as_map_redeemer_key_to_redeemer_val();
    if (mapRedeemerKeyToRedeemerVal) {
      const keys = mapRedeemerKeyToRedeemerVal.keys();
      for (let i = 0; i < keys.len(); i++) {
        const key = keys.get(i);
        const redeemerVal = mapRedeemerKeyToRedeemerVal.get(key);
        if (redeemerVal) {
          evalRedeemers.push({
            ex_units: {
              mem: Number(redeemerVal.ex_units().mem()),
              steps: Number(redeemerVal.ex_units().steps())
            },
            redeemer_index: Number(key.index),
            redeemer_tag: fromCMLRedeemerTag(key.tag())
          });
        }
      }
      return evalRedeemers;
    }
    return evalRedeemers;
  }
  log() {
    function getRandomColor(unit) {
      const seed = unit === "lovelace" ? "1" : unit;
      let num = 0;
      for (let i = 0; i < seed.length; i++) {
        num += seed.charCodeAt(i);
      }
      const r = num * 123 % 256;
      const g = num * 321 % 256;
      const b = num * 213 % 256;
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    const totalBalances = {};
    const balances = {};
    for (const { utxo } of Object.values(this.ledger)) {
      for (const [unit, quantity] of Object.entries(utxo.assets)) {
        if (!balances[utxo.address]) {
          balances[utxo.address] = { [unit]: quantity };
        } else if (!balances[utxo.address]?.[unit]) {
          balances[utxo.address][unit] = quantity;
        } else {
          balances[utxo.address][unit] += quantity;
        }
        if (!totalBalances[unit]) {
          totalBalances[unit] = quantity;
        } else {
          totalBalances[unit] += quantity;
        }
      }
    }
    console.log("\n%cBlockchain state", "color:purple");
    console.log(
      `
    Block height:   %c${this.blockHeight}%c
    Slot:           %c${this.slot}%c
    Unix time:      %c${this.time}
  `,
      "color:yellow",
      "color:white",
      "color:yellow",
      "color:white",
      "color:yellow"
    );
    console.log("\n");
    for (const [address, assets] of Object.entries(balances)) {
      console.log(`Address: %c${address}`, "color:blue", "\n");
      for (const [unit, quantity] of Object.entries(assets)) {
        const barLength = Math.max(
          Math.floor(60 * (Number(quantity) / Number(totalBalances[unit]))),
          1
        );
        console.log(
          `%c${"\u2586".repeat(barLength) + " ".repeat(60 - barLength)}`,
          `color: ${getRandomColor(unit)}`,
          "",
          `${unit}:`,
          quantity,
          ""
        );
      }
      console.log(`
${"\u2581".repeat(60)}
`);
    }
  }
};

// src/maestro.ts
import {
  applyDoubleCborEncoding as applyDoubleCborEncoding3,
  scriptFromNative as scriptFromNative2,
  utxoToCore
} from "@lucid-evolution/utils";
import { fromHex as fromHex3 } from "@lucid-evolution/core-utils";
var Maestro = class {
  url;
  apiKey;
  turboSubmit;
  constructor({ network, apiKey, turboSubmit = false }) {
    this.url = `https://${network}.gomaestro-api.org/v1`;
    this.apiKey = apiKey;
    this.turboSubmit = turboSubmit;
  }
  async getProtocolParameters() {
    const timestampedResult = await fetch(`${this.url}/protocol-parameters`, {
      headers: this.commonHeaders()
    }).then((res) => res.json());
    const result = timestampedResult.data;
    const decimalFromRationalString = (str) => {
      const forwardSlashIndex = str.indexOf("/");
      return parseInt(str.slice(0, forwardSlashIndex)) / parseInt(str.slice(forwardSlashIndex + 1));
    };
    return {
      minFeeA: parseInt(result.min_fee_coefficient),
      minFeeB: parseInt(result.min_fee_constant.ada.lovelace),
      maxTxSize: parseInt(result.max_transaction_size.bytes),
      maxValSize: parseInt(result.max_value_size.bytes),
      keyDeposit: BigInt(result.stake_credential_deposit.ada.lovelace),
      poolDeposit: BigInt(result.stake_pool_deposit.ada.lovelace),
      drepDeposit: BigInt(result.delegate_representative_deposit.ada.lovelace),
      govActionDeposit: BigInt(result.governance_action_deposit.ada.lovelace),
      priceMem: decimalFromRationalString(
        result.script_execution_prices.memory
      ),
      priceStep: decimalFromRationalString(result.script_execution_prices.cpu),
      maxTxExMem: BigInt(result.max_execution_units_per_transaction.memory),
      maxTxExSteps: BigInt(result.max_execution_units_per_transaction.cpu),
      coinsPerUtxoByte: BigInt(result.min_utxo_deposit_coefficient),
      collateralPercentage: parseInt(result.collateral_percentage),
      maxCollateralInputs: parseInt(result.max_collateral_inputs),
      minFeeRefScriptCostPerByte: parseInt(
        result.min_fee_reference_scripts.base
      ),
      costModels: {
        PlutusV1: Object.fromEntries(
          result.plutus_cost_models.plutus_v1.map(
            (value, index) => [index.toString(), value]
          )
        ),
        PlutusV2: Object.fromEntries(
          result.plutus_cost_models.plutus_v2.map(
            (value, index) => [index.toString(), value]
          )
        ),
        PlutusV3: Object.fromEntries(
          result.plutus_cost_models.plutus_v3.map(
            (value, index) => [index.toString(), value]
          )
        )
      }
    };
  }
  async getUtxosInternal(addressOrCredential, unit) {
    const queryPredicate = (() => {
      if (typeof addressOrCredential === "string") {
        return "/addresses/" + addressOrCredential;
      }
      let credentialBech32Query = "/addresses/cred/";
      credentialBech32Query += addressOrCredential.type === "Key" ? CML.Ed25519KeyHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_vkh"
      ) : CML.ScriptHash.from_hex(addressOrCredential.hash).to_bech32(
        "addr_shared_vkh"
      );
      return credentialBech32Query;
    })();
    const qparams = new URLSearchParams({
      count: "100",
      ...unit && { asset: unit }
    });
    const result = await this.getAllPagesData(
      async (qry) => await fetch(qry, {
        headers: this.requireAmountsAsStrings(this.commonHeaders())
      }),
      `${this.url}${queryPredicate}/utxos`,
      qparams,
      "Location: getUtxosInternal. Error: Could not fetch UTxOs from Maestro"
    );
    return result.map(this.maestroUtxoToUtxo);
  }
  getUtxos(addressOrCredential) {
    return this.getUtxosInternal(addressOrCredential);
  }
  getUtxosWithUnit(addressOrCredential, unit) {
    return this.getUtxosInternal(addressOrCredential, unit);
  }
  async getUtxoByUnit(unit) {
    const timestampedAddressesResponse = await fetch(
      `${this.url}/assets/${unit}/addresses?count=2`,
      { headers: this.commonHeaders() }
    );
    const timestampedAddresses = await timestampedAddressesResponse.json();
    if (!timestampedAddressesResponse.ok) {
      if (timestampedAddresses.message) {
        throw new Error(timestampedAddresses.message);
      }
      throw new Error(
        "Location: getUtxoByUnit. Error: Couldn't perform query. Received status code: " + timestampedAddressesResponse.status
      );
    }
    const addressesWithAmount = timestampedAddresses.data;
    if (addressesWithAmount.length === 0) {
      throw new Error("Location: getUtxoByUnit. Error: Unit not found.");
    }
    if (addressesWithAmount.length > 1) {
      throw new Error(
        "Location: getUtxoByUnit. Error: Unit needs to be an NFT or only held by one address."
      );
    }
    const address = addressesWithAmount[0].address;
    const utxos = await this.getUtxosWithUnit(address, unit);
    if (utxos.length > 1) {
      throw new Error(
        "Location: getUtxoByUnit. Error: Unit needs to be an NFT or only held by one address."
      );
    }
    return utxos[0];
  }
  async getUtxosByOutRef(outRefs) {
    const qry = `${this.url}/transactions/outputs`;
    const body = JSON.stringify(
      outRefs.map(({ txHash, outputIndex }) => `${txHash}#${outputIndex}`)
    );
    const utxos = await this.getAllPagesData(
      async (qry2) => await fetch(qry2, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...this.requireAmountsAsStrings(this.commonHeaders())
        },
        body
      }),
      qry,
      new URLSearchParams({}),
      "Location: getUtxosByOutRef. Error: Could not fetch UTxOs by references from Maestro"
    );
    return utxos.map(this.maestroUtxoToUtxo);
  }
  async getDelegation(rewardAddress) {
    const timestampedResultResponse = await fetch(
      `${this.url}/accounts/${rewardAddress}`,
      { headers: this.commonHeaders() }
    );
    if (!timestampedResultResponse.ok) {
      return { poolId: null, rewards: 0n };
    }
    const timestampedResult = await timestampedResultResponse.json();
    const result = timestampedResult.data;
    return {
      poolId: result.delegated_pool || null,
      rewards: BigInt(result.rewards_available)
    };
  }
  async getDatum(datumHash) {
    const timestampedResultResponse = await fetch(
      `${this.url}/datums/${datumHash}`,
      {
        headers: this.commonHeaders()
      }
    );
    if (!timestampedResultResponse.ok) {
      if (timestampedResultResponse.status === 404) {
        throw new Error(`No datum found for datum hash: ${datumHash}`);
      } else {
        throw new Error(
          "Location: getDatum. Error: Couldn't successfully perform query. Received status code: " + timestampedResultResponse.status
        );
      }
    }
    const timestampedResult = await timestampedResultResponse.json();
    return timestampedResult.data.bytes;
  }
  awaitTx(txHash, checkInterval = 3e3) {
    return new Promise((res) => {
      const confirmation = setInterval(async () => {
        const isConfirmedResponse = await fetch(
          `${this.url}/transactions/${txHash}/cbor`,
          {
            headers: this.commonHeaders()
          }
        );
        if (isConfirmedResponse.ok) {
          await isConfirmedResponse.json();
          clearInterval(confirmation);
          await new Promise((res2) => setTimeout(() => res2(1), 1e3));
          return res(true);
        }
      }, checkInterval);
    });
  }
  async submitTx(tx) {
    let queryUrl = `${this.url}/txmanager`;
    queryUrl += this.turboSubmit ? "/turbosubmit" : "";
    const response = await fetch(queryUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/cbor",
        Accept: "text/plain",
        ...this.commonHeaders()
      },
      body: fromHex3(tx)
    });
    const result = await response.text();
    if (!response.ok) {
      if (response.status === 400) throw new Error(result);
      else {
        throw new Error(
          "Could not submit transaction. Received status code: " + response.status
        );
      }
    }
    return result;
  }
  commonHeaders() {
    return { "api-key": this.apiKey, lucid: lucid2 };
  }
  requireAmountsAsStrings(obj) {
    return { ...obj, "amounts-as-strings": "true" };
  }
  maestroUtxoToUtxo(result) {
    return {
      txHash: result.tx_hash,
      outputIndex: result.index,
      assets: (() => {
        const a = {};
        result.assets.forEach((am) => {
          a[am.unit] = BigInt(am.amount);
        });
        return a;
      })(),
      address: result.address,
      datumHash: result.datum ? result.datum.type == "inline" ? void 0 : result.datum.hash : void 0,
      datum: result.datum?.bytes,
      scriptRef: toScriptRef(result.reference_script)
    };
  }
  async getAllPagesData(getResponse, qry, paramsGiven, errorMsg) {
    let nextCursor = null;
    let result = [];
    while (true) {
      if (nextCursor !== null) {
        paramsGiven.set("cursor", nextCursor);
      }
      const response = await getResponse(`${qry}?` + paramsGiven);
      const pageResult = await response.json();
      if (!response.ok) {
        throw new Error(
          `${errorMsg}. Received status code: ${response.status}`
        );
      }
      nextCursor = pageResult.next_cursor;
      result = result.concat(pageResult.data);
      if (nextCursor == null) break;
    }
    return result;
  }
  async evaluateTx(tx, additionalUTxOs) {
    const additionalMaestroUTxOs = (additionalUTxOs || []).map((utxo) => ({
      tx_hash: utxo.txHash,
      index: utxo.outputIndex,
      txout_cbor: utxoToCore(utxo).output().to_cbor_hex()
    }));
    const payload = {
      cbor: tx,
      additional_utxos: additionalMaestroUTxOs
    };
    const res = await fetch(`${this.url}/transactions/evaluate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        "api-key": this.apiKey
      },
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const body = await res.text();
      console.error("Response error:", JSON.stringify(res));
      throw new Error(`Evaluate transaction failed: ${body}`);
    }
    const result = await res.json();
    return result;
  }
};
var toScriptRef = (reference_script) => {
  if (reference_script && reference_script.bytes) {
    switch (reference_script.type) {
      case "native":
        return scriptFromNative2(reference_script.json);
      case "plutusv1":
        return {
          type: "PlutusV1",
          script: applyDoubleCborEncoding3(reference_script.bytes)
        };
      case "plutusv2":
        return {
          type: "PlutusV2",
          script: applyDoubleCborEncoding3(reference_script.bytes)
        };
      case "plutusv3":
        return {
          type: "PlutusV3",
          script: applyDoubleCborEncoding3(reference_script.bytes)
        };
      default:
        return void 0;
    }
  }
};
var lucid2 = package_default.version;

// src/koios.ts
import * as S5 from "@effect/schema/Schema";
import { fromHex as fromHex4 } from "@lucid-evolution/core-utils";
import { fromUnit as fromUnit3 } from "@lucid-evolution/utils";

// src/internal/koios.ts
import {
  HttpClient as HttpClient2,
  HttpClientRequest as HttpClientRequest2,
  HttpClientResponse as HttpClientResponse2
} from "@effect/platform";
import * as S4 from "@effect/schema/Schema";
import { Effect as Effect2, pipe as pipe3 } from "effect";
import { applyDoubleCborEncoding as applyDoubleCborEncoding4 } from "@lucid-evolution/utils";
var ProtocolParametersSchema2 = S4.Struct({
  pvt_motion_no_confidence: S4.Number,
  pvt_committee_normal: S4.Number,
  pvt_committee_no_confidence: S4.Number,
  pvt_hard_fork_initiation: S4.Number,
  pvtpp_security_group: S4.Number,
  dvt_motion_no_confidence: S4.Number,
  dvt_committee_normal: S4.Number,
  dvt_committee_no_confidence: S4.Number,
  dvt_update_to_constitution: S4.Number,
  dvt_hard_fork_initiation: S4.Number,
  dvt_p_p_network_group: S4.Number,
  dvt_p_p_economic_group: S4.Number,
  dvt_p_p_technical_group: S4.Number,
  dvt_p_p_gov_group: S4.Number,
  dvt_treasury_withdrawal: S4.Number,
  committee_min_size: S4.Number,
  committee_max_term_length: S4.Number,
  gov_action_lifetime: S4.Number,
  gov_action_deposit: S4.NumberFromString,
  drep_deposit: S4.NumberFromString,
  drep_activity: S4.Number,
  min_fee_ref_script_cost_per_byte: S4.Number,
  epoch_no: S4.Number,
  min_fee_a: S4.Number,
  min_fee_b: S4.Number,
  max_block_size: S4.Number,
  max_tx_size: S4.Number,
  max_bh_size: S4.Number,
  key_deposit: S4.BigInt,
  pool_deposit: S4.BigInt,
  max_epoch: S4.Number,
  optimal_pool_count: S4.Number,
  influence: S4.Number,
  monetary_expand_rate: S4.Number,
  treasury_growth_rate: S4.Number,
  decentralisation: S4.Number,
  extra_entropy: S4.NullOr(S4.String),
  protocol_major: S4.Number,
  protocol_minor: S4.Number,
  min_utxo_value: S4.String,
  min_pool_cost: S4.String,
  nonce: S4.String,
  block_hash: S4.NullOr(S4.String),
  cost_models: S4.Struct({
    PlutusV1: S4.Array(S4.Number),
    PlutusV2: S4.Array(S4.Number),
    PlutusV3: S4.Array(S4.Number)
  }),
  price_mem: S4.Number,
  price_step: S4.Number,
  max_tx_ex_mem: S4.BigIntFromNumber,
  max_tx_ex_steps: S4.BigIntFromNumber,
  max_block_ex_mem: S4.Number,
  max_block_ex_steps: S4.Number,
  max_val_size: S4.Number,
  collateral_percent: S4.Number,
  max_collateral_inputs: S4.Number,
  coins_per_utxo_size: S4.BigInt
});
var AssetSchema = S4.Struct({
  policy_id: S4.String,
  asset_name: S4.NullOr(S4.String),
  fingerprint: S4.String,
  decimals: S4.Number,
  quantity: S4.String
});
var ReferenceScriptSchema = S4.Struct({
  hash: S4.NullOr(S4.String),
  size: S4.NullOr(S4.Number),
  type: S4.NullOr(S4.String),
  bytes: S4.NullOr(S4.String),
  value: S4.NullOr(S4.Object)
});
var UTxOSchema2 = S4.Struct({
  tx_hash: S4.String,
  tx_index: S4.Number,
  block_time: S4.Number,
  block_height: S4.NullOr(S4.Number),
  value: S4.String,
  datum_hash: S4.NullOr(S4.String),
  inline_datum: S4.NullOr(
    S4.Struct({
      bytes: S4.String,
      value: S4.Object
    })
  ),
  reference_script: S4.NullOr(ReferenceScriptSchema),
  asset_list: S4.NullOr(S4.Array(AssetSchema))
});
var AddressInfoSchema = S4.Array(
  S4.NullishOr(
    S4.Struct({
      address: S4.String,
      balance: S4.String,
      stake_address: S4.NullOr(S4.String),
      script_address: S4.Boolean,
      utxo_set: S4.Array(UTxOSchema2)
    })
  )
);
var InputOutputSchema = S4.Struct({
  payment_addr: S4.Struct({
    bech32: S4.String,
    cred: S4.String
  }),
  stake_addr: S4.NullOr(S4.String),
  tx_hash: S4.String,
  tx_index: S4.Number,
  value: S4.String,
  datum_hash: S4.NullOr(S4.String),
  inline_datum: S4.NullOr(
    S4.Struct({
      bytes: S4.String,
      value: S4.Object
    })
  ),
  reference_script: S4.NullOr(ReferenceScriptSchema),
  asset_list: S4.Array(AssetSchema)
});
var TxInfoSchema = S4.Struct({
  tx_hash: S4.String,
  block_hash: S4.String,
  block_height: S4.Number,
  epoch_no: S4.Number,
  epoch_slot: S4.Number,
  absolute_slot: S4.Number,
  tx_timestamp: S4.Number,
  tx_block_index: S4.Number,
  tx_size: S4.Number,
  total_output: S4.String,
  fee: S4.String,
  treasury_donation: S4.String,
  deposit: S4.String,
  invalid_before: S4.NullOr(S4.String),
  invalid_after: S4.NullOr(S4.String),
  collateral_inputs: S4.NullOr(S4.Array(InputOutputSchema)),
  collateral_output: S4.NullOr(InputOutputSchema),
  reference_inputs: S4.NullOr(S4.Array(InputOutputSchema)),
  inputs: S4.Array(InputOutputSchema),
  outputs: S4.Array(InputOutputSchema),
  withdrawals: S4.NullOr(
    S4.Array(
      S4.Struct({
        amount: S4.String,
        stake_addr: S4.String
      })
    )
  ),
  assets_minted: S4.NullOr(S4.Array(AssetSchema)),
  metadata: S4.NullOr(S4.Object),
  certificates: S4.NullOr(
    S4.Array(
      S4.Struct({
        index: S4.Number,
        type: S4.String,
        info: S4.NullOr(S4.Object)
      })
    )
  ),
  native_scripts: S4.NullOr(
    S4.Array(
      S4.Struct({
        script_hash: S4.String,
        script_json: S4.Object
      })
    )
  ),
  plutus_contracts: S4.NullOr(
    S4.Array(
      S4.Struct({
        address: S4.String,
        spends_input: S4.NullOr(
          S4.Struct({
            tx_hash: S4.String,
            tx_index: S4.Number
          })
        ),
        script_hash: S4.String,
        bytecode: S4.String,
        size: S4.Number,
        valid_contract: S4.Boolean,
        input: S4.Struct({
          redeemer: S4.Struct({
            purpose: S4.Literal("spend", "mint", "cert", "reward"),
            fee: S4.String,
            unit: S4.Struct({
              steps: S4.String,
              mem: S4.String
            }),
            datum: S4.Struct({
              hash: S4.NullOr(S4.String),
              value: S4.NullOr(S4.Object)
            })
          }),
          datum: S4.Struct({
            hash: S4.NullOr(S4.String),
            value: S4.NullOr(S4.Object)
          })
        })
      })
    )
  ),
  //TODO: add S.Struct
  // https://preprod.koios.rest/#post-/tx_info
  voting_procedures: S4.Array(S4.Object),
  //TODO: add S.Struct
  // https://preprod.koios.rest/#post-/tx_info
  proposal_procedures: S4.Object
});
var TxHashSchema = S4.String;
var AssetAddressSchema = S4.Struct({
  payment_address: S4.String,
  stake_address: S4.NullOr(S4.String),
  quantity: S4.String
});
var AccountInfoSchema = S4.Struct({
  delegated_pool: S4.NullOr(S4.String),
  rewards_available: S4.NumberFromString
});
var DatumInfo = S4.Struct({
  bytes: S4.String
});
var postWithSchemaValidation = (url, data, schema) => pipe3(
  HttpClientRequest2.post(url),
  HttpClientRequest2.jsonBody(data),
  Effect2.flatMap(HttpClient2.fetchOk),
  HttpClientResponse2.json,
  Effect2.flatMap(S4.decodeUnknown(schema))
  // Effect.scoped
);
var getWithSchemaValidation = (url, schema) => pipe3(
  HttpClientRequest2.get(url),
  HttpClient2.fetchOk,
  HttpClientResponse2.json,
  Effect2.flatMap(S4.decodeUnknown(schema))
);
var toUTxO = (koiosUTxO, address) => ({
  txHash: koiosUTxO.tx_hash,
  outputIndex: koiosUTxO.tx_index,
  assets: (() => {
    const a = {};
    if (koiosUTxO.asset_list) {
      koiosUTxO.asset_list.forEach((am) => {
        a[am.policy_id + am.asset_name] = BigInt(am.quantity);
      });
    }
    a["lovelace"] = BigInt(koiosUTxO.value);
    return a;
  })(),
  address,
  datumHash: koiosUTxO.inline_datum ? void 0 : koiosUTxO.datum_hash || void 0,
  datum: koiosUTxO.inline_datum ? koiosUTxO.inline_datum.bytes : void 0,
  scriptRef: toScriptRef2(koiosUTxO.reference_script)
});
var toScriptRef2 = (reference_script) => {
  if (reference_script && reference_script.bytes && reference_script.type) {
    switch (reference_script.type) {
      case "plutusV1":
        return {
          type: "PlutusV1",
          script: applyDoubleCborEncoding4(reference_script.bytes)
        };
      case "plutusV2":
        return {
          type: "PlutusV2",
          script: applyDoubleCborEncoding4(reference_script.bytes)
        };
      case "plutusV3":
        return {
          type: "PlutusV3",
          script: applyDoubleCborEncoding4(reference_script.bytes)
        };
      default:
        return void 0;
    }
  }
};
var getUtxosEffect = (baseUrl, addressOrCredential) => {
  const url = `${baseUrl}/address_info`;
  const body = {
    _addresses: [addressOrCredential]
  };
  const schema = AddressInfoSchema;
  const result = pipe3(
    Effect2.if(typeof addressOrCredential === "string", {
      onFalse: () => Effect2.fail("Credential Type is not supported in Koios yet."),
      onTrue: () => postWithSchemaValidation(url, body, schema)
    }),
    Effect2.map(
      ([result2]) => result2 ? result2.utxo_set.map((koiosUtxo) => toUTxO(koiosUtxo, result2.address)) : []
    )
  );
  return result;
};

// src/koios.ts
import { Data as Data2, Effect as Effect3, pipe as pipe4, Schedule as Schedule2 } from "effect";
var KoiosError = class extends Data2.TaggedError("KoiosError") {
  get message() {
    return `${this.cause}`;
  }
};
var Koios = class {
  baseUrl;
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  async getProtocolParameters() {
    const url = `${this.baseUrl}/epoch_params?limit=1`;
    const schema = S5.Array(ProtocolParametersSchema2);
    const [result] = await pipe4(
      getWithSchemaValidation(url, schema),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    return {
      minFeeA: result.min_fee_a,
      minFeeB: result.min_fee_b,
      maxTxSize: result.max_tx_size,
      maxValSize: result.max_val_size,
      keyDeposit: result.key_deposit,
      poolDeposit: result.pool_deposit,
      drepDeposit: BigInt(result.drep_deposit),
      govActionDeposit: BigInt(result.gov_action_deposit),
      priceMem: result.price_mem,
      priceStep: result.price_step,
      maxTxExMem: result.max_tx_ex_mem,
      maxTxExSteps: result.max_tx_ex_steps,
      coinsPerUtxoByte: result.coins_per_utxo_size,
      collateralPercentage: result.collateral_percent,
      maxCollateralInputs: result.max_collateral_inputs,
      minFeeRefScriptCostPerByte: result.min_fee_ref_script_cost_per_byte,
      costModels: {
        PlutusV1: Object.fromEntries(
          result.cost_models.PlutusV1.map((value, index) => [
            index.toString(),
            value
          ])
        ),
        PlutusV2: Object.fromEntries(
          result.cost_models.PlutusV2.map((value, index) => [
            index.toString(),
            value
          ])
        ),
        PlutusV3: Object.fromEntries(
          result.cost_models.PlutusV3.map((value, index) => [
            index.toString(),
            value
          ])
        )
      }
    };
  }
  async getUtxos(addressOrCredential) {
    const result = await pipe4(
      getUtxosEffect(this.baseUrl, addressOrCredential),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    return result;
  }
  async getUtxosWithUnit(addressOrCredential, unit) {
    const result = await pipe4(
      getUtxosEffect(this.baseUrl, addressOrCredential),
      Effect3.map(
        (utxos) => utxos.filter((utxo) => {
          const keys = Object.keys(utxo.assets);
          return keys.length > 0 && keys.includes(unit);
        })
      ),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    return result;
  }
  async getUtxoByUnit(unit) {
    let { policyId, assetName } = fromUnit3(unit);
    const url = `${this.baseUrl}/asset_addresses?_asset_policy=${policyId}&_asset_name=${assetName}`;
    const result = await pipe4(
      getWithSchemaValidation(url, S5.Array(AssetAddressSchema)),
      Effect3.flatMap(
        (adresses) => adresses.length === 0 ? Effect3.fail("Unit not found") : Effect3.succeed(adresses)
      ),
      Effect3.flatMap(
        (adresses) => adresses.length > 1 ? Effect3.fail("Unit needs to be an NFT or only held by one address.") : Effect3.succeed(adresses[0])
      ),
      Effect3.flatMap(
        (address) => getUtxosEffect(this.baseUrl, address.payment_address)
      ),
      Effect3.map(
        (utxos) => utxos.filter((utxo) => {
          const keys = Object.keys(utxo.assets);
          return keys.length > 0 && keys.includes(unit);
        })
      ),
      Effect3.flatMap(
        (utxos) => utxos.length > 1 ? Effect3.fail("Unit needs to be an NFT or only held by one address.") : Effect3.succeed(utxos[0])
      ),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    return result;
  }
  async getUtxosByOutRef(outRefs) {
    const url = `${this.baseUrl}/tx_info`;
    const body = {
      _tx_hashes: [...new Set(outRefs.map((outRef) => outRef.txHash))],
      _assets: true,
      _scripts: true
    };
    const schema = S5.Array(TxInfoSchema);
    const [result] = await pipe4(
      postWithSchemaValidation(url, body, schema),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    if (result) {
      const utxos = result.outputs.map(
        (koiosInputOutput) => toUTxO(
          {
            tx_hash: koiosInputOutput.tx_hash,
            tx_index: koiosInputOutput.tx_index,
            block_time: 0,
            block_height: result.block_height,
            value: koiosInputOutput.value,
            datum_hash: koiosInputOutput.datum_hash,
            inline_datum: koiosInputOutput.inline_datum,
            reference_script: koiosInputOutput.reference_script,
            asset_list: koiosInputOutput.asset_list
          },
          koiosInputOutput.payment_addr.bech32
        )
      );
      return utxos.filter(
        (utxo) => outRefs.some(
          (outRef) => utxo.txHash === outRef.txHash && utxo.outputIndex === outRef.outputIndex
        )
      );
    } else {
      return [];
    }
  }
  async getDelegation(rewardAddress) {
    const body = {
      _stake_addresses: [rewardAddress]
    };
    const url = `${this.baseUrl}/account_info`;
    const result = await pipe4(
      postWithSchemaValidation(
        url,
        body,
        S5.Array(AccountInfoSchema)
      ),
      Effect3.flatMap(
        (result2) => result2.length === 0 ? Effect3.fail("No Delegation Found by Reward Address") : Effect3.succeed(result2[0])
      ),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    return {
      poolId: result.delegated_pool || null,
      rewards: BigInt(result.rewards_available)
    };
  }
  async getDatum(datumHash) {
    const url = `${this.baseUrl}/datum_info`;
    const body = {
      _datum_hashes: [datumHash]
    };
    const result = await pipe4(
      postWithSchemaValidation(url, body, S5.Array(DatumInfo)),
      Effect3.flatMap(
        (result2) => result2.length === 0 ? Effect3.fail("No Datum Found by Datum Hash") : Effect3.succeed(result2[0])
      ),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    return result.bytes;
  }
  async awaitTx(txHash, checkInterval = 2e4) {
    const url = `${this.baseUrl}/tx_info`;
    const body = {
      _tx_hashes: [txHash]
    };
    const schema = S5.Array(TxInfoSchema);
    const result = await pipe4(
      postWithSchemaValidation(url, body, schema),
      Effect3.repeat({
        schedule: Schedule2.exponential(checkInterval),
        until: (result2) => result2.length > 0
      }),
      Effect3.timeout(16e4),
      Effect3.orDie,
      Effect3.as(true),
      Effect3.runPromise
    );
    return result;
  }
  async submitTx(tx) {
    const url = `${this.baseUrl}/submittx`;
    const body = fromHex4(tx);
    const schema = TxHashSchema;
    const result = await pipe4(
      postWithSchemaValidation(url, body, schema),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    return result;
  }
  async evaluateTx(tx, additionalUTxOs) {
    const url = `${this.baseUrl}/ogmios`;
    const body = {
      jsonrpc: "2.0",
      method: "evaluateTransaction",
      params: {
        transaction: { cbor: tx },
        additionalUtxo: toOgmiosUTxOs(additionalUTxOs)
      },
      id: null
    };
    const schema = JSONRPCSchema(S5.Array(RedeemerSchema));
    const result = await pipe4(
      postWithSchemaValidation(url, body, schema),
      Effect3.flatMap(
        (response) => "error" in response ? Effect3.fail(response) : Effect3.succeed(response.result)
      ),
      Effect3.timeout(1e4),
      Effect3.catchAllCause((cause) => new KoiosError({ cause })),
      Effect3.runPromise
    );
    const evalRedeemers = result.map((item) => ({
      ex_units: {
        mem: item.budget.memory,
        steps: item.budget.cpu
      },
      redeemer_index: item.validator.index,
      redeemer_tag: item.validator.purpose
    }));
    return evalRedeemers;
  }
};
export {
  Blockfrost,
  Emulator,
  Koios,
  KoiosError,
  Kupmios,
  KupmiosError,
  Maestro,
  generateEmulatorAccount,
  generateEmulatorAccountFrommPrivateKey
};

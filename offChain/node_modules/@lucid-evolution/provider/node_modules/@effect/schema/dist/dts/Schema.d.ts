/**
 * @since 0.67.0
 */
import * as array_ from "effect/Array";
import * as bigDecimal_ from "effect/BigDecimal";
import type { Brand } from "effect/Brand";
import * as cause_ from "effect/Cause";
import * as chunk_ from "effect/Chunk";
import * as config_ from "effect/Config";
import * as duration_ from "effect/Duration";
import * as Effect from "effect/Effect";
import * as either_ from "effect/Either";
import * as Equivalence from "effect/Equivalence";
import * as exit_ from "effect/Exit";
import * as fiberId_ from "effect/FiberId";
import type { LazyArg } from "effect/Function";
import * as hashMap_ from "effect/HashMap";
import * as hashSet_ from "effect/HashSet";
import * as list_ from "effect/List";
import * as option_ from "effect/Option";
import type * as Order from "effect/Order";
import type { Pipeable } from "effect/Pipeable";
import * as redacted_ from "effect/Redacted";
import * as Request from "effect/Request";
import * as sortedSet_ from "effect/SortedSet";
import type * as Types from "effect/Types";
import type { LazyArbitrary } from "./Arbitrary.js";
import type { ParseOptions } from "./AST.js";
import * as AST from "./AST.js";
import * as ParseResult from "./ParseResult.js";
import * as pretty_ from "./Pretty.js";
import type * as Serializable from "./Serializable.js";
/**
 * @since 0.68.2
 */
export type Simplify<A> = {
    [K in keyof A]: A[K];
} & {};
/**
 * @since 0.67.0
 */
export type SimplifyMutable<A> = {
    -readonly [K in keyof A]: A[K];
} extends infer B ? B : never;
/**
 * @since 0.67.0
 * @category symbol
 */
export declare const TypeId: unique symbol;
/**
 * @since 0.67.0
 * @category symbol
 */
export type TypeId = typeof TypeId;
/**
 * @category model
 * @since 0.67.0
 */
export interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {
    readonly Type: A;
    readonly Encoded: I;
    readonly ast: AST.AST;
    annotations(annotations: Annotations.Schema<A>): Schema<A, I, R>;
}
/**
 * @category model
 * @since 0.67.0
 */
export interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {
}
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const make: <A, I = A, R = never>(ast: AST.AST) => SchemaClass<A, I, R>;
/**
 * @category annotations
 * @since 0.67.0
 */
export declare namespace Annotable {
    /**
     * @since 0.67.0
     */
    type Self<S extends All> = ReturnType<S["annotations"]>;
    /**
     * @since 0.67.0
     */
    type Any = Annotable<any, any, any, unknown>;
    /**
     * @since 0.67.0
     */
    type All = Any | Annotable<any, any, never, unknown> | Annotable<any, never, any, unknown> | Annotable<any, never, never, unknown>;
}
/**
 * @category annotations
 * @since 0.67.0
 */
export interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {
    annotations(annotations: Annotations.Schema<A>): Self;
}
/**
 * @category annotations
 * @since 0.67.0
 */
export interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {
    new (_: never): Schema.Variance<A, I, R>;
}
/**
 * @since 0.67.0
 */
export declare const asSchema: <S extends Schema.All>(schema: S) => Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>;
/**
 * @category formatting
 * @since 0.67.0
 */
export declare const format: <A, I, R>(schema: Schema<A, I, R>) => string;
/**
 * @since 0.67.0
 */
export declare namespace Schema {
    /**
     * @since 0.67.0
     */
    interface Variance<A, I, R> {
        readonly [TypeId]: {
            readonly _A: Types.Invariant<A>;
            readonly _I: Types.Invariant<I>;
            readonly _R: Types.Covariant<R>;
        };
    }
    /**
     * @since 0.67.0
     */
    type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never;
    /**
     * @since 0.67.0
     */
    type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never;
    /**
     * @since 0.67.0
     */
    type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never;
    /**
     * @since 0.67.0
     */
    type ToAsserts<S extends AnyNoContext> = (input: unknown, options?: AST.ParseOptions) => asserts input is Schema.Type<S>;
    /**
     * Any schema, except for `never`.
     *
     * @since 0.67.0
     */
    type Any = Schema<any, any, unknown>;
    /**
     * Any schema with `Context = never`, except for `never`.
     *
     * @since 0.67.0
     */
    type AnyNoContext = Schema<any, any, never>;
    /**
     * Any schema, including `never`.
     *
     * @since 0.67.0
     */
    type All = Any | Schema<any, never, unknown> | Schema<never, any, unknown> | Schema<never, never, unknown>;
    /**
     * Type-level counterpart of `Schema.asSchema` function.
     *
     * @since 0.67.0
     */
    type AsSchema<S extends All> = Schema<Type<S>, Encoded<S>, Context<S>>;
}
/**
 * The `encodedSchema` function allows you to extract the `Encoded` portion of a
 * schema, creating a new schema that conforms to the properties defined in the
 * original schema without retaining any refinements or transformations that
 * were applied previously.
 *
 * @since 0.67.0
 */
export declare const encodedSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>;
/**
 * The `encodedBoundSchema` function is similar to `encodedSchema` but preserves
 * the refinements up to the first transformation point in the original schema.
 *
 * @since 0.67.17
 */
export declare const encodedBoundSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>;
/**
 * The `typeSchema` function allows you to extract the `Type` portion of a
 * schema, creating a new schema that conforms to the properties defined in the
 * original schema without considering the initial encoding or transformation
 * processes.
 *
 * @since 0.67.0
 */
export declare const typeSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<A>;
export { 
/**
 * By default the option `exact` is set to `true`.
 *
 * @throws `ParseError`
 * @category validation
 * @since 0.67.0
 */
asserts, 
/**
 * @category decoding
 * @since 0.67.0
 */
decodeOption, 
/**
 * @throws `ParseError`
 * @category decoding
 * @since 0.67.0
 */
decodeSync, 
/**
 * @category decoding
 * @since 0.67.0
 */
decodeUnknownOption, 
/**
 * @throws `ParseError`
 * @category decoding
 * @since 0.67.0
 */
decodeUnknownSync, 
/**
 * @category encoding
 * @since 0.67.0
 */
encodeOption, 
/**
 * @throws `ParseError`
 * @category encoding
 * @since 0.67.0
 */
encodeSync, 
/**
 * @category encoding
 * @since 0.67.0
 */
encodeUnknownOption, 
/**
 * @throws `ParseError`
 * @category encoding
 * @since 0.67.0
 */
encodeUnknownSync, 
/**
 * By default the option `exact` is set to `true`.
 *
 * @category validation
 * @since 0.67.0
 */
is, 
/**
 * @category validation
 * @since 0.67.0
 */
validateOption, 
/**
 * @throws `ParseError`
 * @category validation
 * @since 0.67.0
 */
validateSync } from "./ParseResult.js";
/**
 * @category encoding
 * @since 0.67.0
 */
export declare const encodeUnknown: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>;
/**
 * @category encoding
 * @since 0.67.0
 */
export declare const encodeUnknownEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError>;
/**
 * @category encoding
 * @since 0.67.0
 */
export declare const encodeUnknownPromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<I>;
/**
 * @category encoding
 * @since 0.67.0
 */
export declare const encode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>;
/**
 * @category encoding
 * @since 0.67.0
 */
export declare const encodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError>;
/**
 * @category encoding
 * @since 0.67.0
 */
export declare const encodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Promise<I>;
/**
 * @category decoding
 * @since 0.67.0
 */
export declare const decodeUnknown: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category decoding
 * @since 0.67.0
 */
export declare const decodeUnknownEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>;
/**
 * @category decoding
 * @since 0.67.0
 */
export declare const decodeUnknownPromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * @category decoding
 * @since 0.67.0
 */
export declare const decode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category decoding
 * @since 0.67.0
 */
export declare const decodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>;
/**
 * @category decoding
 * @since 0.67.0
 */
export declare const decodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * @category validation
 * @since 0.67.0
 */
export declare const validate: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category validation
 * @since 0.67.0
 */
export declare const validateEither: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>;
/**
 * @category validation
 * @since 0.67.0
 */
export declare const validatePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 0.67.0
 */
export declare const isSchema: (u: unknown) => u is Schema.Any;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>> extends AnnotableClass<Literal<Literals>, Literals[number]> {
    readonly literals: Readonly<Literals>;
}
/**
 * @category constructors
 * @since 0.67.0
 */
export declare function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(...literals: Literals): Literal<Literals>;
export declare function Literal(): Never;
export declare function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(...literals: Literals): Schema<Literals[number]>;
/**
 * Creates a new `Schema` from a literal schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { Either } from "effect"
 *
 * const schema = S.Literal("a", "b", "c").pipe(S.pickLiteral("a", "b"))
 *
 * assert.deepStrictEqual(S.decodeSync(schema)("a"), "a")
 * assert.deepStrictEqual(S.decodeSync(schema)("b"), "b")
 * assert.strictEqual(Either.isLeft(S.decodeUnknownEither(schema)("c")), true)
 *
 * @category constructors
 * @since 0.67.0
 */
export declare const pickLiteral: <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) => <I, R>(_schema: Schema<A, I, R>) => Literal<[...L]>;
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const UniqueSymbolFromSelf: <S extends symbol>(symbol: S) => SchemaClass<S>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {
    readonly enums: A;
}
/**
 * @since 0.67.0
 */
export type EnumsDefinition = {
    [x: string]: string | number;
};
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const Enums: <A extends EnumsDefinition>(enums: A) => Enums<A>;
type Join<T> = T extends [infer Head, ...infer Tail] ? `${(Head extends Schema<infer A> ? A : Head) & (AST.LiteralValue)}${Join<Tail>}` : "";
/**
 * @category API interface
 * @since 0.67.17
 */
export interface TemplateLiteral<A> extends SchemaClass<A> {
}
type TemplateLiteralParameter = Schema.AnyNoContext | AST.LiteralValue;
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const TemplateLiteral: <T extends readonly [TemplateLiteralParameter, ...Array<TemplateLiteralParameter>]>(...[head, ...tail]: T) => TemplateLiteral<Join<T>>;
/**
 * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
 * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
 *
 * @category constructors
 * @since 0.67.0
 */
export declare const declare: {
    <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): SchemaClass<A>;
    <const P extends ReadonlyArray<Schema.Any>, I, A>(typeParameters: P, options: {
        readonly decode: (...typeParameters: {
            readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>;
        }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<A, ParseResult.ParseIssue, never>;
        readonly encode: (...typeParameters: {
            readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>;
        }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<I, ParseResult.ParseIssue, never>;
    }, annotations?: Annotations.Schema<A, {
        readonly [K in keyof P]: Schema.Type<P[K]>;
    }>): SchemaClass<A, I, Schema.Context<P[number]>>;
};
/**
 * @category type id
 * @since 0.67.0
 */
export declare const BrandTypeId: unique symbol;
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const fromBrand: <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(constructor: Brand.Constructor<C>, annotations?: Annotations.Filter<C, A>) => <I, R>(self: Schema<A, I, R>) => BrandSchema<A & C, I, R>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const InstanceOfTypeId: unique symbol;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface instanceOf<A> extends AnnotableClass<instanceOf<A>, A> {
}
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A, annotations?: Annotations.Schema<InstanceType<A>>) => instanceOf<InstanceType<A>>;
declare const Undefined_base: SchemaClass<undefined, undefined, never>;
/**
 * @category primitives
 * @since 0.67.0
 */
export declare class Undefined extends Undefined_base {
}
declare const Void_base: SchemaClass<void, void, never>;
/**
 * @category primitives
 * @since 0.67.0
 */
export declare class Void extends Void_base {
}
declare const Null_base: SchemaClass<null, null, never>;
/**
 * @category primitives
 * @since 0.67.0
 */
export declare class Null extends Null_base {
}
declare const Never_base: SchemaClass<never, never, never>;
/**
 * @category primitives
 * @since 0.67.0
 */
export declare class Never extends Never_base {
}
declare const Unknown_base: SchemaClass<unknown, unknown, never>;
/**
 * @category primitives
 * @since 0.67.0
 */
export declare class Unknown extends Unknown_base {
}
declare const Any_base: SchemaClass<any, any, never>;
/**
 * @category primitives
 * @since 0.67.0
 */
export declare class Any extends Any_base {
}
declare const BigIntFromSelf_base: SchemaClass<bigint, bigint, never>;
/**
 * @category primitives
 * @since 0.67.0
 */
export declare class BigIntFromSelf extends BigIntFromSelf_base {
}
declare const SymbolFromSelf_base: SchemaClass<symbol, symbol, never>;
/**
 * @category primitives
 * @since 0.67.0
 */
export declare class SymbolFromSelf extends SymbolFromSelf_base {
}
declare const String$_base: SchemaClass<string, string, never>;
/** @ignore */
declare class String$ extends String$_base {
}
declare const Number$_base: SchemaClass<number, number, never>;
/** @ignore */
declare class Number$ extends Number$_base {
}
declare const Boolean$_base: SchemaClass<boolean, boolean, never>;
/** @ignore */
declare class Boolean$ extends Boolean$_base {
}
declare const Object$_base: SchemaClass<object, object, never>;
/** @ignore */
declare class Object$ extends Object$_base {
}
export { 
/**
 * @category primitives
 * @since 0.67.0
 */
Boolean$ as Boolean, 
/**
 * @category primitives
 * @since 0.67.0
 */
Number$ as Number, 
/**
 * @category primitives
 * @since 0.67.0
 */
Object$ as Object, 
/**
 * @category primitives
 * @since 0.67.0
 */
String$ as String };
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Union<Members extends ReadonlyArray<Schema.Any>> extends AnnotableClass<Union<Members>, Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>> {
    readonly members: Readonly<Members>;
    annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members>;
}
/**
 * @category combinators
 * @since 0.67.0
 */
export declare function Union<Members extends AST.Members<Schema.Any>>(...members: Members): Union<Members>;
export declare function Union<Member extends Schema.Any>(member: Member): Member;
export declare function Union(): typeof Never;
export declare function Union<Members extends ReadonlyArray<Schema.Any>>(...members: Members): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface NullOr<S extends Schema.Any> extends Union<[S, typeof Null]> {
    annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>;
}
/**
 * @category combinators
 * @since 0.67.0
 */
export declare const NullOr: <S extends Schema.Any>(self: S) => NullOr<S>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface UndefinedOr<S extends Schema.Any> extends Union<[S, typeof Undefined]> {
    annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>;
}
/**
 * @category combinators
 * @since 0.67.0
 */
export declare const UndefinedOr: <S extends Schema.Any>(self: S) => UndefinedOr<S>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface NullishOr<S extends Schema.Any> extends Union<[S, typeof Null, typeof Undefined]> {
    annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>;
}
/**
 * @category combinators
 * @since 0.67.0
 */
export declare const NullishOr: <S extends Schema.Any>(self: S) => NullishOr<S>;
/**
 * @category combinators
 * @since 0.67.0
 */
export declare const keyof: <A, I, R>(self: Schema<A, I, R>) => SchemaClass<keyof A>;
/**
 * @since 0.68.0
 */
export declare namespace Element {
    /**
     * @since 0.68.0
     */
    interface Annotations<A> extends Annotations.Doc<A> {
        readonly missingMessage?: AST.MissingMessageAnnotation;
    }
    /**
     * @since 0.68.0
     */
    type Token = "" | "?";
}
/**
 * @category API interface
 * @since 0.68.0
 */
export interface Element<S extends Schema.Any, Token extends Element.Token> extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>> {
    readonly _Token: Token;
    readonly ast: AST.OptionalType;
    readonly from: S;
    annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>;
}
/**
 * @since 0.68.0
 */
export declare const element: <S extends Schema.Any>(self: S) => Element<S, "">;
/**
 * @since 0.67.0
 */
export declare const optionalElement: <S extends Schema.Any>(self: S) => Element<S, "?">;
/**
 * @since 0.67.0
 */
export declare namespace TupleType {
    type ElementsType<Elements, Out extends ReadonlyArray<any> = readonly []> = Elements extends readonly [infer Head, ...infer Tail] ? Head extends Element<infer T, "?"> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]> : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]> : Out;
    type ElementsEncoded<Elements, Out extends ReadonlyArray<any> = readonly []> = Elements extends readonly [infer Head, ...infer Tail] ? Head extends Element<infer T, "?"> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]> : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]> : Out;
    /**
     * @since 0.67.0
     */
    type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>;
    /**
     * @since 0.68.0
     */
    type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, "">>;
    /**
     * @since 0.67.0
     */
    type Type<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends [
        infer Head,
        ...infer Tail
    ] ? Readonly<[
        ...ElementsType<Elements>,
        ...ReadonlyArray<Schema.Type<Head>>,
        ...{
            readonly [K in keyof Tail]: Schema.Type<Tail[K]>;
        }
    ]> : ElementsType<Elements>;
    /**
     * @since 0.67.0
     */
    type Encoded<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends [
        infer Head,
        ...infer Tail
    ] ? Readonly<[
        ...ElementsEncoded<Elements>,
        ...ReadonlyArray<Schema.Encoded<Head>>,
        ...{
            readonly [K in keyof Tail]: Schema.Encoded<Tail[K]>;
        }
    ]> : ElementsEncoded<Elements>;
}
/**
 * @category api interface
 * @since 0.67.0
 */
export interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends AnnotableClass<TupleType<Elements, Rest>, TupleType.Type<Elements, Rest>, TupleType.Encoded<Elements, Rest>, Schema.Context<Elements[number]> | Schema.Context<Rest[number]>> {
    readonly elements: Readonly<Elements>;
    readonly rest: Readonly<Rest>;
}
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {
    annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>;
}
/**
 * @category constructors
 * @since 0.67.0
 */
export declare function Tuple<const Elements extends TupleType.Elements, Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>;
export declare function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {
    readonly value: Value;
    annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>;
}
declare const Array$: <Value extends Schema.Any>(value: Value) => Array$<Value>;
export { 
/**
 * @category constructors
 * @since 0.67.0
 */
Array$ as Array };
/**
 * @category api interface
 * @since 0.67.0
 */
export interface NonEmptyArray<Value extends Schema.Any> extends TupleType<[Value], [Value]> {
    readonly value: Value;
    annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>): NonEmptyArray<Value>;
}
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const NonEmptyArray: <Value extends Schema.Any>(value: Value) => NonEmptyArray<Value>;
/**
 * @since 0.67.0
 */
export declare namespace PropertySignature {
    /**
     * @since 0.67.0
     */
    type Token = "?:" | ":";
    /**
     * @since 0.67.0
     */
    type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<Token, any, Key, Token, any, boolean, unknown>;
    /**
     * @since 0.67.0
     */
    type All<Key extends PropertyKey = PropertyKey> = Any<Key> | PropertySignature<Token, never, Key, Token, any, boolean, unknown> | PropertySignature<Token, any, Key, Token, never, boolean, unknown> | PropertySignature<Token, never, Key, Token, never, boolean, unknown>;
    /**
     * @since 0.67.0
     */
    type AST = PropertySignatureDeclaration | PropertySignatureTransformation;
    /**
     * @since 0.67.0
     */
    interface Annotations<A> extends Annotations.Doc<A> {
        readonly missingMessage?: AST.MissingMessageAnnotation;
    }
}
/**
 * @category PropertySignature
 * @since 0.67.0
 */
export declare class PropertySignatureDeclaration extends AST.OptionalType {
    readonly isReadonly: boolean;
    readonly defaultValue: (() => unknown) | undefined;
    /**
     * @since 0.67.0
     */
    readonly _tag = "PropertySignatureDeclaration";
    constructor(type: AST.AST, isOptional: boolean, isReadonly: boolean, annotations: AST.Annotations, defaultValue: (() => unknown) | undefined);
    /**
     * @since 0.67.0
     */
    toString(): string;
}
/**
 * @category PropertySignature
 * @since 0.67.0
 */
export declare class FromPropertySignature extends AST.OptionalType {
    readonly isReadonly: boolean;
    readonly fromKey?: PropertyKey | undefined;
    constructor(type: AST.AST, isOptional: boolean, isReadonly: boolean, annotations: AST.Annotations, fromKey?: PropertyKey | undefined);
}
/**
 * @category PropertySignature
 * @since 0.67.0
 */
export declare class ToPropertySignature extends AST.OptionalType {
    readonly isReadonly: boolean;
    readonly defaultValue: (() => unknown) | undefined;
    constructor(type: AST.AST, isOptional: boolean, isReadonly: boolean, annotations: AST.Annotations, defaultValue: (() => unknown) | undefined);
}
/**
 * @category PropertySignature
 * @since 0.67.0
 */
export declare class PropertySignatureTransformation {
    readonly from: FromPropertySignature;
    readonly to: ToPropertySignature;
    readonly decode: AST.PropertySignatureTransformation["decode"];
    readonly encode: AST.PropertySignatureTransformation["encode"];
    /**
     * @since 0.67.0
     */
    readonly _tag = "PropertySignatureTransformation";
    constructor(from: FromPropertySignature, to: ToPropertySignature, decode: AST.PropertySignatureTransformation["decode"], encode: AST.PropertySignatureTransformation["encode"]);
    /**
     * @since 0.67.0
     */
    toString(): string;
}
/**
 * @since 0.68.0
 * @category symbol
 */
export declare const PropertySignatureTypeId: unique symbol;
/**
 * @since 0.68.0
 * @category symbol
 */
export type PropertySignatureTypeId = typeof PropertySignatureTypeId;
/**
 * @category PropertySignature
 * @since 0.67.0
 */
export interface PropertySignature<TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean = false, R = never> extends Schema.Variance<Type, Encoded, R>, Pipeable {
    readonly [PropertySignatureTypeId]: null;
    readonly _TypeToken: TypeToken;
    readonly _EncodedToken: EncodedToken;
    readonly _HasDefault: HasDefault;
    readonly _Key: Key;
    readonly ast: PropertySignature.AST;
    annotations(annotations: PropertySignature.Annotations<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>;
}
declare class PropertySignatureImpl<TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean = false, R = never> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {
    readonly ast: PropertySignature.AST;
    readonly [TypeId]: Schema.Variance<Type, Encoded, R>[TypeId];
    readonly [PropertySignatureTypeId]: null;
    readonly _TypeToken: TypeToken;
    readonly _Key: Key;
    readonly _EncodedToken: EncodedToken;
    readonly _HasDefault: HasDefault;
    constructor(ast: PropertySignature.AST);
    pipe(): unknown;
    annotations(annotations: PropertySignature.Annotations<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>;
    toString(): string;
}
/**
 * @category PropertySignature
 * @since 0.67.15
 */
export declare const makePropertySignature: <TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean = false, R = never>(ast: PropertySignature.AST) => PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>;
/**
 * @category API interface
 * @since 1.0.0
 */
export interface propertySignature<S extends Schema.All> extends PropertySignature<":", Schema.Type<S>, never, ":", Schema.Encoded<S>, false, Schema.Context<S>> {
    readonly from: S;
    annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>;
}
/**
 * Lifts a `Schema` into a `PropertySignature`.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
export declare const propertySignature: <S extends Schema.All>(self: S) => propertySignature<S>;
/**
 * Enhances a property signature with a default constructor value.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
export declare const withConstructorDefault: {
    <Type>(defaultValue: () => Types.NoInfer<Type>): <TypeToken extends PropertySignature.Token, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>;
    <TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>, defaultValue: () => Types.NoInfer<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>;
};
/**
 * Enhances a property signature with a default decoding value.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
export declare const withDecodingDefault: {
    <Type>(defaultValue: () => Types.NoInfer<Type>): <Key extends PropertyKey, Encoded, HasDefault extends boolean, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, HasDefault, R>) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, HasDefault, R>;
    <Type, Key extends PropertyKey, Encoded, HasDefault extends boolean, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, HasDefault, R>, defaultValue: () => Types.NoInfer<Type>): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, HasDefault, R>;
};
/**
 * Enhances a property signature with a default decoding value and a default constructor value.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
export declare const withDefaults: {
    <Type>(defaults: {
        constructor: () => Types.NoInfer<Exclude<Type, undefined>>;
        decoding: () => Types.NoInfer<Type>;
    }): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>;
    <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>, defaults: {
        constructor: () => Types.NoInfer<Exclude<Type, undefined>>;
        decoding: () => Types.NoInfer<Type>;
    }): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>;
};
/**
 * Enhances a property signature by specifying a different key for it in the Encoded type.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
export declare const fromKey: {
    <Key extends PropertyKey>(key: Key): <TypeToken extends PropertySignature.Token, Type, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean, R>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>;
    <Type, TypeToken extends PropertySignature.Token, Encoded, EncodedToken extends PropertySignature.Token, HasDefault extends boolean, R, Key extends PropertyKey>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>, key: Key): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>;
};
/**
 * Converts an optional property to a required one through a transformation `Option -> Type`.
 *
 * - `decode`: `none` as argument means the value is missing in the input.
 * - `encode`: `none` as return value means the value will be missing in the output.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
export declare const optionalToRequired: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: {
    readonly decode: (o: option_.Option<FA>) => TI;
    readonly encode: (ti: TI) => option_.Option<FA>;
}) => PropertySignature<":", TA, never, "?:", FI, false, FR | TR>;
/**
 * Converts an optional property to a required one through a transformation `Type -> Option`.
 *
 * - `decode`: `none` as return value means the value will be missing in the output.
 * - `encode`: `none` as argument means the value is missing in the input.
 *
 * @category PropertySignature
 * @since 0.67.15
 */
export declare const requiredToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: {
    readonly decode: (fa: FA) => option_.Option<TI>;
    readonly encode: (o: option_.Option<TI>) => FA;
}) => PropertySignature<"?:", TA, never, ":", FI, false, FR | TR>;
/**
 * Converts an optional property to another optional property through a transformation `Option -> Option`.
 *
 * - `decode`:
 *   - `none` as argument means the value is missing in the input.
 *   - `none` as return value means the value will be missing in the output.
 * - `encode`:
 *   - `none` as argument means the value is missing in the input.
 *   - `none` as return value means the value will be missing in the output.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
export declare const optionalToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: {
    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>;
    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>;
}) => PropertySignature<"?:", TA, never, "?:", FI, false, FR | TR>;
/**
 * @since 0.67.0
 */
export type OptionalOptions<A> = {
    readonly default?: never;
    readonly as?: never;
    readonly exact?: true;
    readonly nullable?: true;
} | {
    readonly default: LazyArg<A>;
    readonly as?: never;
    readonly exact?: true;
    readonly nullable?: true;
} | {
    readonly as: "Option";
    readonly default?: never;
    readonly exact?: never;
    readonly nullable?: never;
    readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>;
} | {
    readonly as: "Option";
    readonly default?: never;
    readonly exact?: never;
    readonly nullable: true;
    readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>;
} | {
    readonly as: "Option";
    readonly default?: never;
    readonly exact: true;
    readonly nullable?: never;
    readonly onNoneEncoding?: never;
} | {
    readonly as: "Option";
    readonly default?: never;
    readonly exact: true;
    readonly nullable: true;
    readonly onNoneEncoding?: LazyArg<option_.Option<null>>;
} | undefined;
/**
 * @category api interface
 * @since 0.67.10
 */
export interface optional<S extends Schema.All> extends PropertySignature<"?:", Schema.Type<S> | undefined, never, "?:", Schema.Encoded<S> | undefined, false, Schema.Context<S>> {
    readonly from: S;
    annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>;
}
/**
 * @category api interface
 * @since 0.67.10
 */
export interface optionalWithOptions<S extends Schema.All, Options> extends PropertySignature<Types.Has<Options, "as" | "default"> extends true ? ":" : "?:", (Types.Has<Options, "as"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>) | (Types.Has<Options, "as" | "default" | "exact"> extends true ? never : undefined), never, "?:", Schema.Encoded<S> | (Types.Has<Options, "nullable"> extends true ? null : never) | (Types.Has<Options, "exact"> extends true ? never : undefined), Types.Has<Options, "default">, Schema.Context<S>> {
    readonly from: S;
    annotations(annotations: PropertySignature.Annotations<(Types.Has<Options, "as"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>) | (Types.Has<Options, "as" | "default" | "exact"> extends true ? never : undefined)>): optionalWithOptions<S, Options>;
}
/**
 * @category PropertySignature
 * @since 0.67.0
 */
export declare const optional: {
    <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(options?: Options): (self: S) => [undefined] extends [Options] ? optional<S> : optionalWithOptions<S, Options>;
    <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(self: S, options?: Options): [undefined] extends [Options] ? optional<S> : optionalWithOptions<S, Options>;
};
/**
 * @since 0.67.0
 */
export declare namespace Struct {
    /**
     * @since 0.67.0
     */
    type Fields = {
        readonly [x: PropertyKey]: Schema.All | PropertySignature.All;
    };
    type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never : F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key : K;
    type EncodedTokenKeys<Fields extends Struct.Fields> = {
        [K in keyof Fields]: Fields[K] extends PropertySignature<PropertySignature.Token, any, PropertyKey, "?:", any, boolean, unknown> | PropertySignature<PropertySignature.Token, any, PropertyKey, "?:", never, boolean, unknown> | PropertySignature<PropertySignature.Token, never, PropertyKey, "?:", any, boolean, unknown> | PropertySignature<PropertySignature.Token, never, PropertyKey, "?:", never, boolean, unknown> ? K : never;
    }[keyof Fields];
    type TypeTokenKeys<Fields extends Struct.Fields> = {
        [K in keyof Fields]: Fields[K] extends OptionalPropertySignature ? K : never;
    }[keyof Fields];
    type OptionalPropertySignature = PropertySignature<"?:", any, PropertyKey, PropertySignature.Token, any, boolean, unknown> | PropertySignature<"?:", any, PropertyKey, PropertySignature.Token, never, boolean, unknown> | PropertySignature<"?:", never, PropertyKey, PropertySignature.Token, any, boolean, unknown> | PropertySignature<"?:", never, PropertyKey, PropertySignature.Token, never, boolean, unknown>;
    /**
     * @since 0.67.0
     */
    type Type<F extends Fields> = Types.UnionToIntersection<{
        [K in keyof F]: F[K] extends OptionalPropertySignature ? {
            readonly [H in K]?: Schema.Type<F[H]>;
        } : {
            readonly [h in K]: Schema.Type<F[h]>;
        };
    }[keyof F]> extends infer Q ? Q : never;
    /**
     * @since 0.67.0
     */
    type Encoded<F extends Fields> = {
        readonly [K in Exclude<keyof F, EncodedTokenKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]>;
    } & {
        readonly [K in EncodedTokenKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]>;
    };
    /**
     * @since 0.67.0
     */
    type Context<F extends Fields> = Schema.Context<F[keyof F]>;
    type PropertySignatureWithDefault = PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, any, true, unknown> | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, never, true, unknown> | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, any, true, unknown> | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, never, true, unknown>;
    /**
     * @since 0.67.0
     */
    type Constructor<F extends Fields> = Types.UnionToIntersection<{
        [K in keyof F]: F[K] extends OptionalPropertySignature ? {
            readonly [H in K]?: Schema.Type<F[H]>;
        } : F[K] extends PropertySignatureWithDefault ? {
            readonly [H in K]?: Schema.Type<F[H]>;
        } : {
            readonly [h in K]: Schema.Type<F[h]>;
        };
    }[keyof F]> extends infer Q ? Q : never;
}
/**
 * @since 0.67.0
 */
export declare namespace IndexSignature {
    /**
     * @since 0.67.0
     */
    type Record = {
        readonly key: Schema.All;
        readonly value: Schema.All;
    };
    /**
     * @since 0.67.0
     */
    type Records = ReadonlyArray<Record>;
    /**
     * @since 0.67.0
     */
    type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>;
    /**
     * @since 0.67.0
     */
    type Type<Records extends IndexSignature.Records> = Types.UnionToIntersection<{
        [K in keyof Records]: {
            readonly [P in Schema.Type<Records[K]["key"]>]: Schema.Type<Records[K]["value"]>;
        };
    }[number]>;
    /**
     * @since 0.67.0
     */
    type Encoded<Records extends IndexSignature.Records> = Types.UnionToIntersection<{
        [K in keyof Records]: {
            readonly [P in Schema.Encoded<Records[K]["key"]>]: Schema.Encoded<Records[K]["value"]>;
        };
    }[number]>;
    /**
     * @since 0.67.0
     */
    type Context<Records extends IndexSignature.Records> = {
        [K in keyof Records]: Schema.Context<Records[K]["key"]> | Schema.Context<Records[K]["value"]>;
    }[number];
}
/**
 * @since 0.67.0
 */
export declare namespace TypeLiteral {
    /**
     * @since 0.67.0
     */
    type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> = Struct.Type<Fields> & IndexSignature.Type<Records>;
    /**
     * @since 0.67.0
     */
    type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> = Struct.Encoded<Fields> & IndexSignature.Encoded<Records>;
    /**
     * @since 0.67.0
     */
    type Constructor<Fields extends Struct.Fields, Records extends IndexSignature.Records> = Struct.Constructor<Fields> & IndexSignature.Type<Records>;
}
/**
 * @category api interface
 * @since 0.67.0
 */
export interface TypeLiteral<Fields extends Struct.Fields, Records extends IndexSignature.Records> extends AnnotableClass<TypeLiteral<Fields, Records>, Simplify<TypeLiteral.Type<Fields, Records>>, Simplify<TypeLiteral.Encoded<Fields, Records>>, Struct.Context<Fields> | IndexSignature.Context<Records>> {
    readonly fields: {
        readonly [K in keyof Fields]: Fields[K];
    };
    readonly records: Readonly<Records>;
    annotations(annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>): TypeLiteral<Fields, Records>;
    make(props: Simplify<TypeLiteral.Constructor<Fields, Records>>, options?: MakeOptions): Simplify<TypeLiteral.Type<Fields, Records>>;
}
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Struct<Fields extends Struct.Fields> extends TypeLiteral<Fields, []> {
    annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>;
    /** @since 0.68.17 */
    pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>;
    /** @since 0.68.17 */
    omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>;
}
/**
 * @category constructors
 * @since 0.67.0
 */
export declare function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(fields: Fields, ...records: Records): TypeLiteral<Fields, Records>;
export declare function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>;
/**
 * @category api interface
 * @since 0.67.14
 */
export interface tag<Tag extends AST.LiteralValue> extends PropertySignature<":", Tag, never, ":", Tag, true, never> {
}
/**
 * Returns a property signature that represents a tag.
 * A tag is a literal value that is used to distinguish between different types of objects.
 * The tag is optional when using the `make` method.
 *
 * @see {@link TaggedStruct}
 *
 * @example
 * import { Schema } from "@effect/schema"
 *
 * const User = Schema.Struct({
 *   _tag: Schema.tag("User"),
 *   name: Schema.String,
 *   age: Schema.Number
 * })
 *
 * assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
 *
 * @since 0.67.14
 */
export declare const tag: <Tag extends AST.LiteralValue>(tag: Tag) => tag<Tag>;
/**
 * @category api interface
 * @since 0.67.14
 */
export type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<{
    _tag: tag<Tag>;
} & Fields>;
/**
 * A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.
 *
 * The tag is optional when using the `make` method.
 *
 * @example
 * import { Schema } from "@effect/schema"
 *
 * const User = Schema.TaggedStruct("User", {
 *   name: Schema.String,
 *   age: Schema.Number
 * })
 *
 * assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
 *
 * @category constructors
 * @since 0.67.14
 */
export declare const TaggedStruct: <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(value: Tag, fields: Fields) => TaggedStruct<Tag, Fields>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Record$<K extends Schema.All, V extends Schema.All> extends TypeLiteral<{}, [{
    key: K;
    value: V;
}]> {
    readonly key: K;
    readonly value: V;
    annotations(annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{
        key: K;
        value: V;
    }]>>>): Record$<K, V>;
}
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const Record: <K extends Schema.All, V extends Schema.All>(key: K, value: V) => Record$<K, V>;
/**
 * @category struct transformations
 * @since 0.67.0
 */
export declare const pick: <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) => <R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R>;
/**
 * @category struct transformations
 * @since 0.67.0
 */
export declare const omit: <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) => <R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R>;
/**
 * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
 * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * // ---------------------------------------------
 * // use case: pull out a single field from a
 * // struct through a transformation
 * // ---------------------------------------------
 *
 * const mytable = S.Struct({
 *   column1: S.NumberFromString,
 *   column2: S.Number
 * })
 *
 * // const pullOutColumn: S.Schema<number, {
 * //     readonly column1: string;
 * // }, never>
 * const pullOutColumn = mytable.pipe(S.pluck("column1"))
 *
 * console.log(S.decodeUnknownEither(S.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
 * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
 *
 * @category struct transformations
 * @since 0.67.0
 */
export declare const pluck: {
    <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => Schema<A[K], {
        readonly [P in K]: I[P];
    }, R>;
    <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): Schema<A[K], {
        readonly [P in K]: I[P];
    }, R>;
};
/**
 * @category branding
 * @since 0.67.0
 */
export interface BrandSchema<A extends Brand<any>, I = A, R = never> extends AnnotableClass<BrandSchema<A, I, R>, A, I, R> {
    make(a: Brand.Unbranded<A>, options?: MakeOptions): A;
}
/**
 * @category api interface
 * @since 0.67.0
 */
export interface brand<S extends Schema.Any, B extends string | symbol> extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>> {
    annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>;
}
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
 * type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
 *
 * @category branding
 * @since 0.67.0
 */
export declare const brand: <S extends Schema.AnyNoContext, B extends string | symbol>(brand: B, annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>) => (self: S) => brand<S, B>;
/**
 * @category combinators
 * @since 0.67.0
 */
export declare const partial: {
    <const Options extends {
        readonly exact: true;
    } | undefined>(options?: Options): <A, I, R>(self: Schema<A, I, R>) => SchemaClass<{
        [K in keyof A]?: A[K] | ([undefined] extends [Options] ? undefined : never);
    }, {
        [K in keyof I]?: I[K] | ([undefined] extends [Options] ? undefined : never);
    }, R>;
    <A, I, R, const Options extends {
        readonly exact: true;
    } | undefined>(self: Schema<A, I, R>, options?: Options): SchemaClass<{
        [K in keyof A]?: A[K] | ([undefined] extends [Options] ? undefined : never);
    }, {
        [K in keyof I]?: I[K] | ([undefined] extends [Options] ? undefined : never);
    }, R>;
};
/**
 * @category combinators
 * @since 0.67.0
 */
export declare const required: <A, I, R>(self: Schema<A, I, R>) => SchemaClass<{ [K in keyof A]-?: A[K]; }, { [K in keyof I]-?: I[K]; }, R>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface mutable<S extends Schema.Any> extends AnnotableClass<mutable<S>, SimplifyMutable<Schema.Type<S>>, SimplifyMutable<Schema.Encoded<S>>, Schema.Context<S>> {
}
/**
 * Creates a new schema with shallow mutability applied to its properties.
 *
 * @param schema - The original schema to make properties mutable (shallowly).
 *
 * @category combinators
 * @since 0.67.0
 */
export declare const mutable: <S extends Schema.Any>(schema: S) => mutable<S>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface extend<Self extends Schema.Any, That extends Schema.Any> extends AnnotableClass<extend<Self, That>, Schema.Type<Self> & Schema.Type<That>, Schema.Encoded<Self> & Schema.Encoded<That>, Schema.Context<Self> | Schema.Context<That>> {
}
/**
 * Extends a schema by adding additional fields or index signatures.
 *
 * 1) It only supports **structs**, refinements of structs, unions of structs, suspensions of structs
 * (informally `Supported = Struct | Refinement of Supported | Union of Supported | suspend(() => Supported)`)
 * 2) The arguments must represent disjoint types (e.g., `extend(Struct({ a: String }), Struct({ a: String })))` raises an error)
 *
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * const schema = Schema.Struct({
 *   a: Schema.String,
 *   b: Schema.String
 * })
 *
 * // const extended: S.Schema<{
 * //     readonly [x: string]: string;
 * //     readonly a: string;
 * //     readonly b: string;
 * //     readonly c: string;
 * // }>
 * const extended = Schema.asSchema(schema.pipe(
 *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
 *   Schema.extend(Schema.Record(Schema.String, Schema.String)) // <= you can add index signatures
 * ))
 *
 * @category combinators
 * @since 0.67.0
 */
export declare const extend: {
    <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>;
    <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>;
};
/**
 * @category combinators
 * @since 0.67.0
 */
export declare const compose: {
    <D, C extends B, R2, B>(to: Schema<D, C, R2>): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>;
    <D, C, R2>(to: Schema<D, C, R2>): <B extends C, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>;
    <C, B, R2>(to: Schema<C, B, R2>, options?: {
        readonly strict: true;
    }): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<C, A, R1 | R2>;
    <D, C, R2>(to: Schema<D, C, R2>, options: {
        readonly strict: false;
    }): <B, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>;
    <B, A, R1, D, C extends B, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2>;
    <B extends C, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2>;
    <B, A, R1, C, R2>(from: Schema<B, A, R1>, to: Schema<C, B, R2>, options?: {
        readonly strict: true;
    }): SchemaClass<C, A, R1 | R2>;
    <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>, options: {
        readonly strict: false;
    }): SchemaClass<D, A, R1 | R2>;
};
/**
 * @category api interface
 * @since 0.67.0
 */
export interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {
}
/**
 * @category constructors
 * @since 0.67.0
 */
export declare const suspend: <A, I, R>(f: () => Schema<A, I, R>) => suspend<A, I, R>;
/**
 * @since 0.68.8
 * @category symbol
 */
export declare const refineTypeId: unique symbol;
/**
 * @since 0.68.8
 * @category symbol
 */
export type refineTypeId = typeof refineTypeId;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface refine<A, From extends Schema.Any> extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>> {
    readonly [refineTypeId]: From;
    readonly from: From;
    readonly filter: (a: Schema.Type<From>, options: ParseOptions, self: AST.Refinement) => option_.Option<ParseResult.ParseIssue>;
    make(a: Schema.Type<From>, options?: MakeOptions): A;
}
/**
 * @category api interface
 * @since 0.67.0
 */
export interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {
}
/**
 * @category filtering
 * @since 0.68.0
 */
export interface FilterIssue {
    readonly path: ReadonlyArray<PropertyKey>;
    readonly message: string;
}
/**
 * @category filtering
 * @since 0.68.0
 */
export type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue;
type FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>;
/**
 * @category filtering
 * @since 0.67.0
 */
export declare function filter<C extends A, B extends A, A = C>(refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B, annotations?: Annotations.Filter<C & B, C>): <I, R>(self: Schema<C, I, R>) => refine<C & B, Schema<A, I, R>>;
export declare function filter<A, B extends A>(refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B, annotations?: Annotations.Filter<B, A>): <I, R>(self: Schema<A, I, R>) => refine<B, Schema<A, I, R>>;
export declare function filter<S extends Schema.Any>(predicate: (a: Types.NoInfer<Schema.Type<S>>, options: ParseOptions, self: AST.Refinement) => FilterReturnType, annotations?: Annotations.Filter<Types.NoInfer<Schema.Type<S>>>): (self: S) => filter<S>;
/**
 * @category api interface
 * @since 0.68.17
 */
export interface filterEffect<S extends Schema.Any, FD = never> extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD> {
}
/**
 * @category transformations
 * @since 0.68.17
 */
export declare const filterEffect: {
    <S extends Schema.Any, FD>(f: (a: Types.NoInfer<Schema.Type<S>>, options: ParseOptions, self: AST.Transformation) => Effect.Effect<FilterReturnType, never, FD>): (self: S) => filterEffect<S, FD>;
    <S extends Schema.Any, RD>(self: S, f: (a: Types.NoInfer<Schema.Type<S>>, options: ParseOptions, self: AST.Transformation) => Effect.Effect<FilterReturnType, never, RD>): filterEffect<S, RD>;
};
/**
 * @category api interface
 * @since 0.67.0
 */
export interface transformOrFail<From extends Schema.Any, To extends Schema.Any, R = never> extends AnnotableClass<transformOrFail<From, To, R>, Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R> {
    readonly from: From;
    readonly to: To;
}
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided decoding functions.
 *
 * @category transformations
 * @since 0.67.0
 */
export declare const transformOrFail: {
    <To extends Schema.Any, From extends Schema.Any, RD, RE>(to: To, options: {
        readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>;
        readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>;
        readonly strict?: true;
    } | {
        readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>;
        readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>;
        readonly strict: false;
    }): (from: From) => transformOrFail<From, To, RD | RE>;
    <To extends Schema.Any, From extends Schema.Any, RD, RE>(from: From, to: To, options: {
        readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>;
        readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>;
        readonly strict?: true;
    } | {
        readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>;
        readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>;
        readonly strict: false;
    }): transformOrFail<From, To, RD | RE>;
};
/**
 * @category api interface
 * @since 0.67.0
 */
export interface transform<From extends Schema.Any, To extends Schema.Any> extends transformOrFail<From, To> {
    annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>;
}
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided mapping functions.
 *
 * @category transformations
 * @since 0.67.0
 */
export declare const transform: {
    <To extends Schema.Any, From extends Schema.Any>(to: To, options: {
        readonly decode: (fromA: Schema.Type<From>) => Schema.Encoded<To>;
        readonly encode: (toI: Schema.Encoded<To>) => Schema.Type<From>;
        readonly strict?: true;
    } | {
        readonly decode: (fromA: Schema.Type<From>) => unknown;
        readonly encode: (toI: Schema.Encoded<To>) => unknown;
        readonly strict: false;
    }): (from: From) => transform<From, To>;
    <To extends Schema.Any, From extends Schema.Any>(from: From, to: To, options: {
        readonly decode: (fromA: Schema.Type<From>) => Schema.Encoded<To>;
        readonly encode: (toI: Schema.Encoded<To>) => Schema.Type<From>;
        readonly strict?: true;
    } | {
        readonly decode: (fromA: Schema.Type<From>) => unknown;
        readonly encode: (toI: Schema.Encoded<To>) => unknown;
        readonly strict: false;
    }): transform<From, To>;
};
/**
 * @category api interface
 * @since 0.67.0
 */
export interface transformLiteral<Type, Encoded> extends Annotable<transformLiteral<Type, Encoded>, Type, Encoded> {
}
/**
 * Creates a new `Schema` which transforms literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const schema = S.transformLiteral(0, "a")
 *
 * assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
 *
 * @category constructors
 * @since 0.67.0
 */
export declare const transformLiteral: <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(from: Encoded, to: Type) => transformLiteral<Type, Encoded>;
/**
 * Creates a new `Schema` which maps between corresponding literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const Animal = S.transformLiterals(
 *   [0, "cat"],
 *   [1, "dog"],
 *   [2, "cow"]
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Animal)(1), "dog")
 *
 * @category constructors
 * @since 0.67.0
 */
export declare function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Union<{
    -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]>;
}>;
export declare function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(pairs: [Encoded, Type]): transformLiteral<Type, Encoded>;
export declare function transformLiterals<const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Schema<A[number][1], A[number][0]>;
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "effect/Function"
 *
 * const Circle = S.Struct({ radius: S.Number })
 * const Square = S.Struct({ sideLength: S.Number })
 * const Shape = S.Union(
 *   Circle.pipe(S.attachPropertySignature("kind", "circle")),
 *   Square.pipe(S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 0.67.0
 */
export declare const attachPropertySignature: {
    <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(key: K, value: V, annotations?: Annotations.Schema<Simplify<A & {
        readonly [k in K]: V;
    }>>): <I, R>(schema: SchemaClass<A, I, R>) => Schema<Simplify<A & {
        readonly [k in K]: V;
    }>, I, R>;
    <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(schema: Schema<A, I, R>, key: K, value: V, annotations?: Annotations.Schema<Simplify<A & {
        readonly [k in K]: V;
    }>>): SchemaClass<Simplify<A & {
        readonly [k in K]: V;
    }>, I, R>;
};
/**
 * @category annotations
 * @since 0.67.0
 */
export declare namespace Annotations {
    /**
     * @category annotations
     * @since 0.67.0
     */
    interface Doc<A> extends AST.Annotations {
        readonly title?: AST.TitleAnnotation;
        readonly description?: AST.DescriptionAnnotation;
        readonly documentation?: AST.DocumentationAnnotation;
        readonly examples?: AST.ExamplesAnnotation<A>;
        readonly default?: AST.DefaultAnnotation<A>;
    }
    /**
     * @since 0.67.0
     */
    interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {
        readonly identifier?: AST.IdentifierAnnotation;
        readonly message?: AST.MessageAnnotation;
        readonly typeId?: AST.TypeAnnotation | {
            id: AST.TypeAnnotation;
            annotation: unknown;
        };
        readonly jsonSchema?: AST.JSONSchemaAnnotation;
        readonly arbitrary?: (...arbitraries: {
            readonly [K in keyof TypeParameters]: LazyArbitrary<TypeParameters[K]>;
        }) => LazyArbitrary<A>;
        readonly pretty?: (...pretties: {
            readonly [K in keyof TypeParameters]: pretty_.Pretty<TypeParameters[K]>;
        }) => pretty_.Pretty<A>;
        readonly equivalence?: (...equivalences: {
            readonly [K in keyof TypeParameters]: Equivalence.Equivalence<TypeParameters[K]>;
        }) => Equivalence.Equivalence<A>;
        readonly concurrency?: AST.ConcurrencyAnnotation;
        readonly batching?: AST.BatchingAnnotation;
        readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation;
        readonly parseOptions?: AST.ParseOptions;
    }
    /**
     * @since 0.67.0
     */
    interface Filter<A, P = A> extends Schema<A, readonly [P]> {
    }
}
/**
 * @category annotations
 * @since 0.67.0
 */
export declare const annotations: {
    <S extends Annotable.All>(annotations: Annotations.Schema<Schema.Type<S>>): (self: S) => Annotable.Self<S>;
    <S extends Annotable.All>(self: S, annotations: Annotations.Schema<Schema.Type<S>>): Annotable.Self<S>;
};
type Rename<A, M> = {
    [K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K] : never : K]: A[K];
};
/**
 * @category renaming
 * @since 0.67.0
 */
export declare const rename: {
    <A, const M extends {
        readonly [K in keyof A]?: PropertyKey;
    } & {
        readonly [K in Exclude<keyof M, keyof A>]: never;
    }>(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>;
    <A, I, R, const M extends {
        readonly [K in keyof A]?: PropertyKey;
    } & {
        readonly [K in Exclude<keyof M, keyof A>]: never;
    }>(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>;
};
/**
 * @category type id
 * @since 0.67.0
 */
export declare const TrimmedTypeId: unique symbol;
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string filters
 * @since 0.67.0
 */
export declare const trimmed: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const MaxLengthTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type MaxLengthTypeId = typeof MaxLengthTypeId;
/**
 * @category string filters
 * @since 0.67.0
 */
export declare const maxLength: <A extends string>(maxLength: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const MinLengthTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type MinLengthTypeId = typeof MinLengthTypeId;
/**
 * @category string filters
 * @since 0.67.0
 */
export declare const minLength: <A extends string>(minLength: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const PatternTypeId: unique symbol;
/**
 * @category string filters
 * @since 0.67.0
 */
export declare const pattern: <A extends string>(regex: RegExp, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const StartsWithTypeId: unique symbol;
/**
 * @category string filters
 * @since 0.67.0
 */
export declare const startsWith: <A extends string>(startsWith: string, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const EndsWithTypeId: unique symbol;
/**
 * @category string filters
 * @since 0.67.0
 */
export declare const endsWith: <A extends string>(endsWith: string, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const IncludesTypeId: unique symbol;
/**
 * @category string filters
 * @since 0.67.0
 */
export declare const includes: <A extends string>(searchString: string, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LowercasedTypeId: unique symbol;
/**
 * Verifies that a string is lowercased.
 *
 * @category string filters
 * @since 0.67.0
 */
export declare const lowercased: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
declare const Lowercased_base: filter<Schema<string, string, never>>;
/**
 * @category string constructors
 * @since 0.67.0
 */
export declare class Lowercased extends Lowercased_base {
}
/**
 * @category type id
 * @since 0.68.18
 */
export declare const CapitalizedTypeId: unique symbol;
/**
 * Verifies that a string is capitalized.
 *
 * @category string filters
 * @since 0.68.18
 */
export declare const capitalized: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
declare const Capitalized_base: filter<Schema<string, string, never>>;
/**
 * @category string constructors
 * @since 0.68.18
 */
export declare class Capitalized extends Capitalized_base {
}
/**
 * @category type id
 * @since 0.68.18
 */
export declare const UncapitalizedTypeId: unique symbol;
/**
 * Verifies that a string is uncapitalized.
 *
 * @category string filters
 * @since 0.68.18
 */
export declare const uncapitalized: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
declare const Uncapitalized_base: filter<Schema<string, string, never>>;
/**
 * @category string constructors
 * @since 0.68.18
 */
export declare class Uncapitalized extends Uncapitalized_base {
}
/**
 * @category type id
 * @since 0.67.0
 */
export declare const UppercasedTypeId: unique symbol;
/**
 * Verifies that a string is uppercased.
 *
 * @category string filters
 * @since 0.67.0
 */
export declare const uppercased: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
declare const Uppercased_base: filter<Schema<string, string, never>>;
/**
 * @category string constructors
 * @since 0.67.0
 */
export declare class Uppercased extends Uppercased_base {
}
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LengthTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type LengthTypeId = typeof LengthTypeId;
/**
 * @category string filters
 * @since 0.67.0
 */
export declare const length: <A extends string>(length: number | {
    readonly min: number;
    readonly max: number;
}, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
declare const Char_base: filter<Schema<string, string, never>>;
/**
 * A schema representing a single character.
 *
 * @category string constructors
 * @since 0.67.0
 */
export declare class Char extends Char_base {
}
/**
 * @category string filters
 * @since 0.67.0
 */
export declare const nonEmpty: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
declare const Lowercase_base: transform<typeof String$, typeof Lowercased>;
/**
 * This schema converts a string to lowercase.
 *
 * @category string transformations
 * @since 0.67.0
 */
export declare class Lowercase extends Lowercase_base {
}
declare const Uppercase_base: transform<typeof String$, typeof Uppercased>;
/**
 * This schema converts a string to uppercase.
 *
 * @category string transformations
 * @since 0.67.0
 */
export declare class Uppercase extends Uppercase_base {
}
declare const Capitalize_base: transform<typeof String$, typeof Capitalized>;
/**
 * This schema converts a string to capitalized one.
 *
 * @category string transformations
 * @since 0.68.18
 */
export declare class Capitalize extends Capitalize_base {
}
declare const Uncapitalize_base: transform<typeof String$, typeof Uncapitalized>;
/**
 * This schema converts a string to uncapitalized one.
 *
 * @category string transformations
 * @since 0.68.18
 */
export declare class Uncapitalize extends Uncapitalize_base {
}
declare const Trimmed_base: filter<Schema<string, string, never>>;
/**
 * @category string constructors
 * @since 0.67.0
 */
export declare class Trimmed extends Trimmed_base {
}
declare const Trim_base: transform<typeof String$, typeof Trimmed>;
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string transformations
 * @since 0.67.0
 */
export declare class Trim extends Trim_base {
}
/**
 * Returns a schema that allows splitting a string into an array of strings.
 *
 * @category string transformations
 * @since 0.67.0
 */
export declare const split: (separator: string) => transform<typeof String$, Array$<typeof String$>>;
/**
 * @since 0.67.0
 */
export type ParseJsonOptions = {
    readonly reviver?: Parameters<typeof JSON.parse>[1];
    readonly replacer?: Parameters<typeof JSON.stringify>[1];
    readonly space?: Parameters<typeof JSON.stringify>[2];
};
/**
 * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
 * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.
 *
 * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.
 *
 * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson())(`{"a":"1"}`), { a: "1" })
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson(S.Struct({ a: S.NumberFromString })))(`{"a":"1"}`), { a: 1 })
 *
 * @category string transformations
 * @since 0.67.0
 */
export declare const parseJson: {
    <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): SchemaClass<A, string, R>;
    (options?: ParseJsonOptions): SchemaClass<unknown, string>;
};
declare const NonEmpty_base: filter<Schema<string, string, never>>;
/**
 * @category string constructors
 * @since 0.67.0
 */
export declare class NonEmpty extends NonEmpty_base {
}
/**
 * @category type id
 * @since 0.67.0
 */
export declare const UUIDTypeId: unique symbol;
declare const UUID_base: filter<Schema<string, string, never>>;
/**
 * Represents a Universally Unique Identifier (UUID).
 *
 * This schema ensures that the provided string adheres to the standard UUID format.
 *
 * @category string constructors
 * @since 0.67.0
 */
export declare class UUID extends UUID_base {
}
/**
 * @category type id
 * @since 0.67.0
 */
export declare const ULIDTypeId: unique symbol;
declare const ULID_base: filter<Schema<string, string, never>>;
/**
 * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).
 *
 * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
 * This schema ensures that the provided string adheres to the standard ULID format.
 *
 * @category string constructors
 * @since 0.67.0
 */
export declare class ULID extends ULID_base {
}
/**
 * @category type id
 * @since 0.67.0
 */
export declare const FiniteTypeId: unique symbol;
/**
 * Ensures that the provided value is a finite number.
 *
 * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.
 *
 * @category number filters
 * @since 0.67.0
 */
export declare const finite: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const GreaterThanTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type GreaterThanTypeId = typeof GreaterThanTypeId;
/**
 * This filter checks whether the provided number is greater than the specified minimum.
 *
 * @category number filters
 * @since 0.67.0
 */
export declare const greaterThan: <A extends number>(min: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const GreaterThanOrEqualToTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type GreaterThanOrEqualToTypeId = typeof GreaterThanOrEqualToTypeId;
/**
 * This filter checks whether the provided number is greater than or equal to the specified minimum.
 *
 * @category number filters
 * @since 0.67.0
 */
export declare const greaterThanOrEqualTo: <A extends number>(min: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const MultipleOfTypeId: unique symbol;
/**
 * @category number filters
 * @since 0.67.0
 */
export declare const multipleOf: <A extends number>(divisor: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const IntTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type IntTypeId = typeof IntTypeId;
/**
 * @category number filters
 * @since 0.67.0
 */
export declare const int: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LessThanTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type LessThanTypeId = typeof LessThanTypeId;
/**
 * This filter checks whether the provided number is less than the specified maximum.
 *
 * @category number filters
 * @since 0.67.0
 */
export declare const lessThan: <A extends number>(max: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LessThanOrEqualToTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type LessThanOrEqualToTypeId = typeof LessThanOrEqualToTypeId;
/**
 * This schema checks whether the provided number is less than or equal to the specified maximum.
 *
 * @category number filters
 * @since 0.67.0
 */
export declare const lessThanOrEqualTo: <A extends number>(max: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const BetweenTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type BetweenTypeId = typeof BetweenTypeId;
/**
 * This filter checks whether the provided number falls within the specified minimum and maximum values.
 *
 * @category number filters
 * @since 0.67.0
 */
export declare const between: <A extends number>(min: number, max: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const NonNaNTypeId: unique symbol;
/**
 * @category number filters
 * @since 0.67.0
 */
export declare const nonNaN: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category number filters
 * @since 0.67.0
 */
export declare const positive: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category number filters
 * @since 0.67.0
 */
export declare const negative: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category number filters
 * @since 0.67.0
 */
export declare const nonPositive: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category number filters
 * @since 0.67.0
 */
export declare const nonNegative: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number transformations
 * @since 0.67.0
 */
export declare const clamp: (minimum: number, maximum: number) => <A extends number, I, R>(self: Schema<A, I, R>) => transform<Schema<A, I, R>, filter<Schema<A>>>;
/**
 * Transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number transformations
 * @since 0.67.0
 */
export declare const parseNumber: <A extends string, I, R>(self: Schema<A, I, R>) => transformOrFail<Schema<A, I, R>, typeof Number$>;
declare const NumberFromString_base: transformOrFail<Schema<string, string, never>, typeof Number$, never>;
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number constructors
 * @since 0.67.0
 */
export declare class NumberFromString extends NumberFromString_base {
}
declare const Finite_base: filter<Schema<number, number, never>>;
/**
 * @category number constructors
 * @since 0.67.0
 */
export declare class Finite extends Finite_base {
}
declare const Int_base: filter<Schema<number, number, never>>;
/**
 * @category number constructors
 * @since 0.67.0
 */
export declare class Int extends Int_base {
}
declare const NonNaN_base: filter<Schema<number, number, never>>;
/**
 * @category number constructors
 * @since 0.67.0
 */
export declare class NonNaN extends NonNaN_base {
}
declare const Positive_base: filter<Schema<number, number, never>>;
/**
 * @category number constructors
 * @since 0.67.0
 */
export declare class Positive extends Positive_base {
}
declare const Negative_base: filter<Schema<number, number, never>>;
/**
 * @category number constructors
 * @since 0.67.0
 */
export declare class Negative extends Negative_base {
}
declare const NonPositive_base: filter<Schema<number, number, never>>;
/**
 * @category number constructors
 * @since 0.67.0
 */
export declare class NonPositive extends NonPositive_base {
}
declare const NonNegative_base: filter<Schema<number, number, never>>;
/**
 * @category number constructors
 * @since 0.67.0
 */
export declare class NonNegative extends NonNegative_base {
}
/**
 * @category type id
 * @since 0.67.0
 */
export declare const JsonNumberTypeId: unique symbol;
declare const JsonNumber_base: filter<typeof Number$>;
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category number constructors
 * @since 0.67.0
 */
export declare class JsonNumber extends JsonNumber_base {
}
declare const Not_base: transform<typeof Boolean$, typeof Boolean$>;
/**
 * @category boolean transformations
 * @since 0.67.0
 */
export declare class Not extends Not_base {
}
declare const Symbol$_base: transform<typeof String$, typeof SymbolFromSelf>;
/** @ignore */
declare class Symbol$ extends Symbol$_base {
}
export { 
/**
 * This schema transforms a `string` into a `symbol`.
 *
 * @category symbol transformations
 * @since 0.67.0
 */
Symbol$ as Symbol };
/**
 * @category type id
 * @since 0.67.0
 */
export declare const GreaterThanBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type GreaterThanBigIntTypeId = typeof GreaterThanBigIntTypeId;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const greaterThanBigInt: <A extends bigint>(min: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const GreaterThanOrEqualToBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type GreaterThanOrEqualToBigIntTypeId = typeof GreaterThanOrEqualToBigIntTypeId;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const greaterThanOrEqualToBigInt: <A extends bigint>(min: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LessThanBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type LessThanBigIntTypeId = typeof LessThanBigIntTypeId;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const lessThanBigInt: <A extends bigint>(max: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LessThanOrEqualToBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type LessThanOrEqualToBigIntTypeId = typeof LessThanOrEqualToBigIntTypeId;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const lessThanOrEqualToBigInt: <A extends bigint>(max: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const BetweenBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type BetweenBigIntTypeId = typeof BetweenBigIntTypeId;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const betweenBigInt: <A extends bigint>(min: bigint, max: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const positiveBigInt: <A extends bigint>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const negativeBigInt: <A extends bigint>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const nonNegativeBigInt: <A extends bigint>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category bigint filters
 * @since 0.67.0
 */
export declare const nonPositiveBigInt: <A extends bigint>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint transformations
 * @since 0.67.0
 */
export declare const clampBigInt: (minimum: bigint, maximum: bigint) => <A extends bigint, I, R>(self: Schema<A, I, R>) => transform<Schema<A, I, R>, filter<Schema<A>>>;
declare const BigInt$_base: transformOrFail<typeof String$, typeof BigIntFromSelf, never>;
/** @ignore */
declare class BigInt$ extends BigInt$_base {
}
export { 
/**
 * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @category bigint transformations
 * @since 0.67.0
 */
BigInt$ as BigInt };
/**
 * @category bigint constructors
 * @since 0.67.0
 */
export declare const PositiveBigIntFromSelf: filter<Schema<bigint>>;
/**
 * @category bigint constructors
 * @since 0.67.0
 */
export declare const PositiveBigInt: filter<Schema<bigint, string>>;
/**
 * @category bigint constructors
 * @since 0.67.0
 */
export declare const NegativeBigIntFromSelf: filter<Schema<bigint>>;
/**
 * @category bigint constructors
 * @since 0.67.0
 */
export declare const NegativeBigInt: filter<Schema<bigint, string>>;
/**
 * @category bigint constructors
 * @since 0.67.0
 */
export declare const NonPositiveBigIntFromSelf: filter<Schema<bigint>>;
/**
 * @category bigint constructors
 * @since 0.67.0
 */
export declare const NonPositiveBigInt: filter<Schema<bigint, string>>;
/**
 * @category bigint constructors
 * @since 0.67.0
 */
export declare const NonNegativeBigIntFromSelf: filter<Schema<bigint>>;
/**
 * @category bigint constructors
 * @since 0.67.0
 */
export declare const NonNegativeBigInt: filter<Schema<bigint, string>>;
declare const BigIntFromNumber_base: transformOrFail<typeof Number$, typeof BigIntFromSelf, never>;
/**
 * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.
 *
 * It returns an error if the value can't be safely encoded as a `number` due to being out of range.
 *
 * @category bigint transformations
 * @since 0.67.0
 */
export declare class BigIntFromNumber extends BigIntFromNumber_base {
}
/**
 * @category api interface
 * @since 0.67.21
 */
export interface RedactedFromSelf<Value extends Schema.Any> extends AnnotableClass<RedactedFromSelf<Value>, redacted_.Redacted<Schema.Type<Value>>, redacted_.Redacted<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Redacted constructors
 * @since 0.67.21
 */
export declare const RedactedFromSelf: <Value extends Schema.Any>(value: Value) => RedactedFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.21
 */
export interface Redacted<Value extends Schema.Any> extends AnnotableClass<Redacted<Value>, redacted_.Redacted<Schema.Type<Value>>, Schema.Encoded<Value>, Schema.Context<Value>> {
}
/**
 * A schema that transforms any type `A` into a `Redacted<A>`.
 *
 * @category Redacted transformations
 * @since 0.67.21
 */
export declare const Redacted: <Value extends Schema.Any>(value: Value) => Redacted<Value>;
declare const DurationFromSelf_base: SchemaClass<duration_.Duration, duration_.Duration, never>;
/**
 * @category Duration constructors
 * @since 0.67.0
 */
export declare class DurationFromSelf extends DurationFromSelf_base {
}
declare const DurationFromNanos_base: transformOrFail<typeof BigIntFromSelf, typeof DurationFromSelf, never>;
/**
 * A schema that transforms a `bigint` tuple into a `Duration`.
 * Treats the value as the number of nanoseconds.
 *
 * @category Duration transformations
 * @since 0.67.0
 */
export declare class DurationFromNanos extends DurationFromNanos_base {
}
declare const DurationFromMillis_base: transform<typeof Number$, typeof DurationFromSelf>;
/**
 * A schema that transforms a `number` tuple into a `Duration`.
 * Treats the value as the number of milliseconds.
 *
 * @category Duration transformations
 * @since 0.67.0
 */
export declare class DurationFromMillis extends DurationFromMillis_base {
}
declare const Duration_base: transform<Schema<readonly [seconds: number, nanos: number], readonly [seconds: number, nanos: number], never>, typeof DurationFromSelf>;
/**
 * A schema that transforms a `[number, number]` tuple into a `Duration`.
 *
 * @category Duration transformations
 * @since 0.67.0
 */
export declare class Duration extends Duration_base {
}
/**
 * Clamps a `Duration` between a minimum and a maximum value.
 *
 * @category Duration transformations
 * @since 0.67.0
 */
export declare const clampDuration: (minimum: duration_.DurationInput, maximum: duration_.DurationInput) => <A extends duration_.Duration, I, R>(self: Schema<A, I, R>) => transform<Schema<A, I, R>, filter<Schema<A>>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LessThanDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 0.67.0
 */
export declare const lessThanDuration: <A extends duration_.Duration>(max: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LessThanOrEqualToDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 0.67.0
 */
export declare const lessThanOrEqualToDuration: <A extends duration_.Duration>(max: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const GreaterThanDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 0.67.0
 */
export declare const greaterThanDuration: <A extends duration_.Duration>(min: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const GreaterThanOrEqualToDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 0.67.0
 */
export declare const greaterThanOrEqualToDuration: <A extends duration_.Duration>(min: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const BetweenDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 0.67.0
 */
export declare const betweenDuration: <A extends duration_.Duration>(minimum: duration_.DurationInput, maximum: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category Uint8Array constructors
 * @since 0.67.0
 */
export declare const Uint8ArrayFromSelf: Schema<Uint8Array>;
declare const Uint8Array$: Schema<Uint8Array, ReadonlyArray<number>>;
export { 
/**
 * A schema that transforms a `number` array into a `Uint8Array`.
 *
 * @category Uint8Array transformations
 * @since 0.67.0
 */
Uint8Array$ as Uint8Array };
/**
 * @category Encoding transformations
 * @since 0.67.0
 */
export declare const Base64: Schema<Uint8Array, string>;
/**
 * @category Encoding transformations
 * @since 0.67.0
 */
export declare const Base64Url: Schema<Uint8Array, string>;
/**
 * @category Encoding transformations
 * @since 0.67.0
 */
export declare const Hex: Schema<Uint8Array, string>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const MinItemsTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type MinItemsTypeId = typeof MinItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 0.67.0
 */
export declare const minItems: <A>(n: number, annotations?: Annotations.Filter<ReadonlyArray<A>>) => <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => filter<Schema<ReadonlyArray<A>, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const MaxItemsTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type MaxItemsTypeId = typeof MaxItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 0.67.0
 */
export declare const maxItems: <A>(n: number, annotations?: Annotations.Filter<ReadonlyArray<A>>) => <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => filter<Schema<ReadonlyArray<A>, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const ItemsCountTypeId: unique symbol;
/**
 * @category type id
 * @since 0.67.0
 */
export type ItemsCountTypeId = typeof ItemsCountTypeId;
/**
 * @category ReadonlyArray filters
 * @since 0.67.0
 */
export declare const itemsCount: <A>(n: number, annotations?: Annotations.Filter<ReadonlyArray<A>>) => <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => filter<Schema<ReadonlyArray<A>, I, R>>;
/**
 * @category ReadonlyArray transformations
 * @since 0.67.0
 */
export declare const getNumberIndexedAccess: <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(self: Schema<A, I, R>) => SchemaClass<A[number], I[number], R>;
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.
 *
 * @category ReadonlyArray transformations
 * @since 0.67.0
 */
export declare const head: <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>) => SchemaClass<option_.Option<A>, I, R>;
/**
 * Retrieves the first element of a `ReadonlyArray`.
 *
 * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.
 *
 * @category ReadonlyArray transformations
 * @since 0.67.0
 */
export declare const headOrElse: {
    <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => SchemaClass<A, I, R>;
    <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R>;
};
/**
 * @category type id
 * @since 0.67.0
 */
export declare const ValidDateTypeId: unique symbol;
/**
 * Defines a filter that specifically rejects invalid dates, such as `new
 * Date("Invalid Date")`. This filter ensures that only properly formatted and
 * valid date objects are accepted, enhancing data integrity by preventing
 * erroneous date values from being processed.
 *
 * @category Date filters
 * @since 0.67.0
 */
export declare const validDate: (annotations?: Annotations.Filter<Date>) => <I, R>(self: Schema<Date, I, R>) => filter<Schema<Date, I, R>>;
declare const DateFromSelf_base: SchemaClass<Date, Date, never>;
/**
 * Describes a schema that accommodates potentially invalid `Date` instances,
 * such as `new Date("Invalid Date")`, without rejection.
 *
 * @category Date constructors
 * @since 0.67.0
 */
export declare class DateFromSelf extends DateFromSelf_base {
}
declare const ValidDateFromSelf_base: filter<Schema<Date, Date, never>>;
/**
 * Defines a schema that ensures only valid dates are accepted. This schema
 * rejects values like `new Date("Invalid Date")`, which, despite being a `Date`
 * instance, represents an invalid date. Such stringent validation ensures that
 * all date objects processed through this schema are properly formed and
 * represent real dates.
 *
 * @category Date constructors
 * @since 0.67.0
 */
export declare class ValidDateFromSelf extends ValidDateFromSelf_base {
}
declare const DateFromString_base: transform<typeof String$, typeof DateFromSelf>;
/**
 * Defines a schema that attempts to convert a `string` to a `Date` object using
 * the `new Date` constructor. This conversion is lenient, meaning it does not
 * reject strings that do not form valid dates (e.g., using `new Date("Invalid
 * Date")` results in a `Date` object, despite being invalid).
 *
 * @category Date transformations
 * @since 0.67.0
 */
export declare class DateFromString extends DateFromString_base {
}
declare const Date$_base: filter<Schema<Date, string, never>>;
/** @ignore */
declare class Date$ extends Date$_base {
}
export { 
/**
 * This schema converts a `string` into a `Date` object using the `new Date`
 * constructor. It ensures that only valid date strings are accepted,
 * rejecting any strings that would result in an invalid date, such as `new
 * Date("Invalid Date")`.
 *
 * @category Date transformations
 * @since 0.67.0
 */
Date$ as Date };
declare const DateFromNumber_base: transform<typeof Number$, typeof DateFromSelf>;
/**
 * Defines a schema that converts a `number` into a `Date` object using the `new
 * Date` constructor. This schema does not validate the numerical input,
 * allowing potentially invalid values such as `NaN`, `Infinity`, and
 * `-Infinity` to be converted into `Date` objects. During the encoding process,
 * any invalid `Date` object will be encoded to `NaN`.
 *
 * @category Date transformations
 * @since 0.67.0
 */
export declare class DateFromNumber extends DateFromNumber_base {
}
/**
 * @category Option utils
 * @since 0.67.0
 */
export type OptionEncoded<I> = {
    readonly _tag: "None";
} | {
    readonly _tag: "Some";
    readonly value: I;
};
/**
 * @category api interface
 * @since 0.67.0
 */
export interface OptionFromSelf<Value extends Schema.Any> extends AnnotableClass<OptionFromSelf<Value>, option_.Option<Schema.Type<Value>>, option_.Option<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 0.67.0
 */
export declare const OptionFromSelf: <Value extends Schema.Any>(value: Value) => OptionFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Option<Value extends Schema.Any> extends AnnotableClass<Option<Value>, option_.Option<Schema.Type<Value>>, OptionEncoded<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 0.67.0
 */
export declare const Option: <Value extends Schema.Any>(value: Value) => Option<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface OptionFromNullOr<Value extends Schema.Any> extends AnnotableClass<OptionFromNullOr<Value>, option_.Option<Schema.Type<Value>>, Schema.Encoded<Value> | null, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 0.67.0
 */
export declare const OptionFromNullOr: <Value extends Schema.Any>(value: Value) => OptionFromNullOr<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface OptionFromNullishOr<Value extends Schema.Any> extends AnnotableClass<OptionFromNullishOr<Value>, option_.Option<Schema.Type<Value>>, Schema.Encoded<Value> | null | undefined, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 0.67.0
 */
export declare const OptionFromNullishOr: <Value extends Schema.Any>(value: Value, onNoneEncoding: null | undefined) => OptionFromNullishOr<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface OptionFromUndefinedOr<Value extends Schema.Any> extends AnnotableClass<OptionFromUndefinedOr<Value>, option_.Option<Schema.Type<Value>>, Schema.Encoded<Value> | undefined, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 0.67.0
 */
export declare const OptionFromUndefinedOr: <Value extends Schema.Any>(value: Value) => OptionFromUndefinedOr<Value>;
/**
 * @category Either utils
 * @since 0.67.0
 */
export type RightEncoded<IA> = {
    readonly _tag: "Right";
    readonly right: IA;
};
/**
 * @category Either utils
 * @since 0.67.0
 */
export type LeftEncoded<IE> = {
    readonly _tag: "Left";
    readonly left: IE;
};
/**
 * @category Either utils
 * @since 0.67.0
 */
export type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface EitherFromSelf<R extends Schema.Any, L extends Schema.Any> extends AnnotableClass<EitherFromSelf<R, L>, either_.Either<Schema.Type<R>, Schema.Type<L>>, either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>, Schema.Context<R> | Schema.Context<L>> {
}
/**
 * @category Either transformations
 * @since 0.67.0
 */
export declare const EitherFromSelf: <R extends Schema.Any, L extends Schema.Any>({ left, right }: {
    readonly left: L;
    readonly right: R;
}) => EitherFromSelf<R, L>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Either<R extends Schema.Any, L extends Schema.Any> extends AnnotableClass<Either<R, L>, either_.Either<Schema.Type<R>, Schema.Type<L>>, EitherEncoded<Schema.Encoded<R>, Schema.Encoded<L>>, Schema.Context<R> | Schema.Context<L>> {
}
/**
 * @category Either transformations
 * @since 0.67.0
 */
export declare const Either: <R extends Schema.Any, L extends Schema.Any>({ left, right }: {
    readonly left: L;
    readonly right: R;
}) => Either<R, L>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface EitherFromUnion<R extends Schema.Any, L extends Schema.Any> extends AnnotableClass<EitherFromUnion<R, L>, either_.Either<Schema.Type<R>, Schema.Type<L>>, Schema.Encoded<R> | Schema.Encoded<L>, Schema.Context<R> | Schema.Context<L>> {
}
/**
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * // Schema<string | number, Either<string, number>>
 * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })
 *
 * @category Either transformations
 * @since 0.67.0
 */
export declare const EitherFromUnion: <R extends Schema.Any, L extends Schema.Any>({ left, right }: {
    readonly left: L;
    readonly right: R;
}) => EitherFromUnion<R, L>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends AnnotableClass<ReadonlyMapFromSelf<K, V>, ReadonlyMap<Schema.Type<K>, Schema.Type<V>>, ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category ReadonlyMap
 * @since 0.67.0
 */
export declare const ReadonlyMapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => ReadonlyMapFromSelf<K, V>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends AnnotableClass<MapFromSelf<K, V>, Map<Schema.Type<K>, Schema.Type<V>>, ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category Map
 * @since 0.67.0
 */
export declare const MapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => MapFromSelf<K, V>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any> extends AnnotableClass<ReadonlyMap$<K, V>, ReadonlyMap<Schema.Type<K>, Schema.Type<V>>, ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category ReadonlyMap transformations
 * @since 0.67.0
 */
export declare const ReadonlyMap: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => ReadonlyMap$<K, V>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Map$<K extends Schema.Any, V extends Schema.Any> extends AnnotableClass<Map$<K, V>, Map<Schema.Type<K>, Schema.Type<V>>, ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>, Schema.Context<K> | Schema.Context<V>> {
}
declare const map: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => Map$<K, V>;
export { 
/**
 * @category Map transformations
 * @since 0.67.0
 */
map as Map };
/**
 * @category ReadonlyMap transformations
 * @since 0.68.15
 */
export declare const ReadonlyMapFromRecord: <KA, KR, VA, VI, VR>({ key, value }: {
    key: Schema<KA, string, KR>;
    value: Schema<VA, VI, VR>;
}) => Schema<ReadonlyMap<KA, VA>, {
    readonly [x: string]: VI;
}, KR | VR>;
/**
 * @category Map transformations
 * @since 0.68.15
 */
export declare const MapFromRecord: <KA, KR, VA, VI, VR>({ key, value }: {
    key: Schema<KA, string, KR>;
    value: Schema<VA, VI, VR>;
}) => Schema<Map<KA, VA>, {
    readonly [x: string]: VI;
}, KR | VR>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface ReadonlySetFromSelf<Value extends Schema.Any> extends AnnotableClass<ReadonlySetFromSelf<Value>, ReadonlySet<Schema.Type<Value>>, ReadonlySet<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category ReadonlySet
 * @since 0.67.0
 */
export declare const ReadonlySetFromSelf: <Value extends Schema.Any>(value: Value) => ReadonlySetFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface SetFromSelf<Value extends Schema.Any> extends AnnotableClass<SetFromSelf<Value>, Set<Schema.Type<Value>>, ReadonlySet<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Set
 * @since 0.67.0
 */
export declare const SetFromSelf: <Value extends Schema.Any>(value: Value) => SetFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface ReadonlySet$<Value extends Schema.Any> extends AnnotableClass<ReadonlySet$<Value>, ReadonlySet<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category ReadonlySet transformations
 * @since 0.67.0
 */
export declare const ReadonlySet: <Value extends Schema.Any>(value: Value) => ReadonlySet$<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Set$<Value extends Schema.Any> extends AnnotableClass<Set$<Value>, Set<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
declare const set: <Value extends Schema.Any>(value: Value) => Set$<Value>;
export { 
/**
 * @category Set transformations
 * @since 0.67.0
 */
set as Set };
declare const BigDecimalFromSelf_base: SchemaClass<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>;
/**
 * @category BigDecimal constructors
 * @since 0.67.0
 */
export declare class BigDecimalFromSelf extends BigDecimalFromSelf_base {
}
declare const BigDecimal_base: transformOrFail<typeof String$, typeof BigDecimalFromSelf, never>;
/**
 * @category BigDecimal transformations
 * @since 0.67.0
 */
export declare class BigDecimal extends BigDecimal_base {
}
declare const BigDecimalFromNumber_base: transformOrFail<typeof Number$, typeof BigDecimalFromSelf, never>;
/**
 * A schema that transforms a `number` into a `BigDecimal`.
 * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.
 *
 * @category BigDecimal transformations
 * @since 0.67.0
 */
export declare class BigDecimalFromNumber extends BigDecimalFromNumber_base {
}
/**
 * @category type id
 * @since 0.67.0
 */
export declare const GreaterThanBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const greaterThanBigDecimal: <A extends bigDecimal_.BigDecimal>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const GreaterThanOrEqualToBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const greaterThanOrEqualToBigDecimal: <A extends bigDecimal_.BigDecimal>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LessThanBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const lessThanBigDecimal: <A extends bigDecimal_.BigDecimal>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const LessThanOrEqualToBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const lessThanOrEqualToBigDecimal: <A extends bigDecimal_.BigDecimal>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const PositiveBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const positiveBigDecimal: <A extends bigDecimal_.BigDecimal>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category BigDecimal constructors
 * @since 0.67.0
 */
export declare const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const NonNegativeBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const nonNegativeBigDecimal: <A extends bigDecimal_.BigDecimal>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category BigDecimal constructors
 * @since 0.67.0
 */
export declare const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const NegativeBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const negativeBigDecimal: <A extends bigDecimal_.BigDecimal>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category BigDecimal constructors
 * @since 0.67.0
 */
export declare const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const NonPositiveBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const nonPositiveBigDecimal: <A extends bigDecimal_.BigDecimal>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * @category BigDecimal constructors
 * @since 0.67.0
 */
export declare const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>>;
/**
 * @category type id
 * @since 0.67.0
 */
export declare const BetweenBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 0.67.0
 */
export declare const betweenBigDecimal: <A extends bigDecimal_.BigDecimal>(minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>;
/**
 * Clamps a `BigDecimal` between a minimum and a maximum value.
 *
 * @category BigDecimal transformations
 * @since 0.67.0
 */
export declare const clampBigDecimal: (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) => <A extends bigDecimal_.BigDecimal, I, R>(self: Schema<A, I, R>) => transform<Schema<A, I, R>, filter<Schema<A>>>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface ChunkFromSelf<Value extends Schema.Any> extends AnnotableClass<ChunkFromSelf<Value>, chunk_.Chunk<Schema.Type<Value>>, chunk_.Chunk<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Chunk
 * @since 0.67.0
 */
export declare const ChunkFromSelf: <Value extends Schema.Any>(value: Value) => ChunkFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Chunk<Value extends Schema.Any> extends AnnotableClass<Chunk<Value>, chunk_.Chunk<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Chunk transformations
 * @since 0.67.0
 */
export declare const Chunk: <Value extends Schema.Any>(value: Value) => Chunk<Value>;
/**
 * @category api interface
 * @since 0.67.23
 */
export interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends AnnotableClass<NonEmptyChunkFromSelf<Value>, chunk_.NonEmptyChunk<Schema.Type<Value>>, chunk_.NonEmptyChunk<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Chunk
 * @since 0.67.23
 */
export declare const NonEmptyChunkFromSelf: <Value extends Schema.Any>(value: Value) => NonEmptyChunkFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.23
 */
export interface NonEmptyChunk<Value extends Schema.Any> extends AnnotableClass<NonEmptyChunk<Value>, chunk_.NonEmptyChunk<Schema.Type<Value>>, array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Chunk transformations
 * @since 0.67.23
 */
export declare const NonEmptyChunk: <Value extends Schema.Any>(value: Value) => NonEmptyChunk<Value>;
/**
 * @category Data transformations
 * @since 0.67.0
 */
export declare const DataFromSelf: <R, I extends Readonly<Record<string, any>> | ReadonlyArray<any>, A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(item: Schema<A, I, R>) => SchemaClass<A, I, R>;
/**
 * @category Data transformations
 * @since 0.67.0
 */
export declare const Data: <R, I extends Readonly<Record<string, any>> | ReadonlyArray<any>, A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(item: Schema<A, I, R>) => SchemaClass<A, I, R>;
type MissingSelfGeneric<Usage extends string, Params extends string = ""> = `Missing \`Self\` generic - use \`class Self extends ${Usage}<Self>()(${Params}{ ... })\``;
type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto> extends Schema<Self, Simplify<I>, R> {
    new (props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>, options?: MakeOptions): Struct.Type<Fields> & Omit<Inherited, keyof Fields> & Proto;
    make<Args extends Array<any>, X>(this: {
        new (...args: Args): X;
    }, ...args: Args): X;
    annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>;
    readonly fields: {
        readonly [K in keyof Fields]: Fields[K];
    };
    readonly identifier: string;
    extend<Extended = never>(identifier: string): <newFields extends Struct.Fields>(fields: newFields | HasFields<newFields>, annotations?: Annotations.Schema<Extended>) => [Extended] extends [never] ? MissingSelfGeneric<"Base.extend"> : Class<Extended, Fields & newFields, I & Struct.Encoded<newFields>, R | Struct.Context<newFields>, C & Struct.Constructor<newFields>, Self, Proto>;
    transformOrFail<Transformed = never>(identifier: string): <newFields extends Struct.Fields, R2, R3>(fields: newFields, options: {
        readonly decode: (input: Simplify<Struct.Type<Fields>>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Simplify<Struct.Type<Fields & newFields>>, ParseResult.ParseIssue, R2>;
        readonly encode: (input: Simplify<Struct.Type<Fields & newFields>>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>;
    }, annotations?: Annotations.Schema<Transformed>) => [Transformed] extends [never] ? MissingSelfGeneric<"Base.transform"> : Class<Transformed, Fields & newFields, I, R | Struct.Context<newFields> | R2 | R3, C & Struct.Constructor<newFields>, Self, Proto>;
    transformOrFailFrom<Transformed = never>(identifier: string): <newFields extends Struct.Fields, R2, R3>(fields: newFields, options: {
        readonly decode: (input: Simplify<I>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Simplify<I & Struct.Encoded<newFields>>, ParseResult.ParseIssue, R2>;
        readonly encode: (input: Simplify<I & Struct.Encoded<newFields>>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<I, ParseResult.ParseIssue, R3>;
    }, annotations?: Annotations.Schema<Transformed>) => [Transformed] extends [never] ? MissingSelfGeneric<"Base.transformFrom"> : Class<Transformed, Fields & newFields, I, R | Struct.Context<newFields> | R2 | R3, C & Struct.Constructor<newFields>, Self, Proto>;
}
type HasFields<Fields extends Struct.Fields> = Struct<Fields> | {
    readonly [refineTypeId]: HasFields<Fields>;
};
/**
 * @category classes
 * @since 0.67.0
 */
export declare const Class: <Self = never>(identifier: string) => <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>, annotations?: Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric<"Class"> : Class<Self, Fields, Struct.Encoded<Fields>, Struct.Context<Fields>, Struct.Constructor<Fields>, {}, {}>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends Class<Self, Fields, Struct.Encoded<Fields>, Struct.Context<Fields>, Struct.Constructor<Omit<Fields, "_tag">>, {}, {}> {
    readonly _tag: Tag;
}
/**
 * @category classes
 * @since 0.67.0
 */
export declare const TaggedClass: <Self = never>(identifier?: string) => <Tag extends string, Fields extends Struct.Fields>(tag: Tag, fieldsOr: Fields | HasFields<Fields>, annotations?: Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric<"TaggedClass", `"Tag", `> : TaggedClass<Self, Tag, {
    readonly _tag: PropertySignature<":", Tag, never, ":", Tag, true, never>;
} & Fields>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends Class<Self, Fields, Struct.Encoded<Fields>, Struct.Context<Fields>, Struct.Constructor<Omit<Fields, "_tag">>, {}, cause_.YieldableError> {
    readonly _tag: Tag;
}
/**
 * @category classes
 * @since 0.67.0
 */
export declare const TaggedError: <Self = never>(identifier?: string) => <Tag extends string, Fields extends Struct.Fields>(tag: Tag, fieldsOr: Fields | HasFields<Fields>, annotations?: Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric<"TaggedError", `"Tag", `> : TaggedErrorClass<Self, Tag, {
    readonly _tag: PropertySignature<":", Tag, never, ":", Tag, true, never>;
} & Fields>;
/**
 * @category classes
 * @since 0.67.0
 */
export interface TaggedRequest<Tag extends string, A, I, R, SuccessType, SuccessEncoded, FailureType, FailureEncoded, SuccessAndFailureR> extends Request.Request<SuccessType, FailureType>, Serializable.SerializableWithResult<A, I, R, SuccessType, SuccessEncoded, FailureType, FailureEncoded, SuccessAndFailureR> {
    readonly _tag: Tag;
}
/**
 * @category classes
 * @since 0.67.0
 */
export declare namespace TaggedRequest {
    /**
     * @category classes
     * @since 0.67.0
     */
    type Any = TaggedRequest<string, any, any, any, any, any, any, any, any> | TaggedRequest<string, any, any, any, any, any, never, never, any>;
}
/**
 * @category api interface
 * @since 0.67.0
 */
export interface TaggedRequestClass<Self, Tag extends string, Fields extends Struct.Fields, Failure extends Schema.All, Success extends Schema.All> extends Class<Self, Fields, Struct.Encoded<Fields>, Struct.Context<Fields>, Struct.Constructor<Omit<Fields, "_tag">>, TaggedRequest<Tag, Self, Struct.Encoded<Fields>, Struct.Context<Fields>, Schema.Type<Success>, Schema.Encoded<Success>, Schema.Type<Failure>, Schema.Encoded<Failure>, Schema.Context<Success> | Schema.Context<Failure>>, {}> {
    readonly _tag: Tag;
}
/**
 * @category classes
 * @since 0.67.0
 */
export declare const TaggedRequest: <Self = never>(identifier?: string) => <Tag extends string, Fields extends Struct.Fields, Failure extends Schema.All, Success extends Schema.All>(tag: Tag, Failure: Failure, Success: Success, fields: Fields, annotations?: Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric<"TaggedRequest", `"Tag", SuccessSchema, FailureSchema, `> : TaggedRequestClass<Self, Tag, {
    readonly _tag: PropertySignature<":", Tag, never, ":", Tag, true, never>;
} & Fields, Failure, Success>;
type MakeOptions = boolean | {
    readonly disableValidation?: boolean;
};
/**
 * @category FiberId
 * @since 0.67.0
 */
export type FiberIdEncoded = {
    readonly _tag: "Composite";
    readonly left: FiberIdEncoded;
    readonly right: FiberIdEncoded;
} | {
    readonly _tag: "None";
} | {
    readonly _tag: "Runtime";
    readonly id: number;
    readonly startTimeMillis: number;
};
declare const FiberIdFromSelf_base: SchemaClass<fiberId_.FiberId, fiberId_.FiberId, never>;
/**
 * @category FiberId constructors
 * @since 0.67.0
 */
export declare class FiberIdFromSelf extends FiberIdFromSelf_base {
}
declare const FiberId_base: transform<Schema<FiberIdEncoded, FiberIdEncoded, never>, typeof FiberIdFromSelf>;
/**
 * @category FiberId transformations
 * @since 0.67.0
 */
export declare class FiberId extends FiberId_base {
}
/**
 * @category Cause utils
 * @since 0.67.0
 */
export type CauseEncoded<E> = {
    readonly _tag: "Empty";
} | {
    readonly _tag: "Fail";
    readonly error: E;
} | {
    readonly _tag: "Die";
    readonly defect: unknown;
} | {
    readonly _tag: "Interrupt";
    readonly fiberId: FiberIdEncoded;
} | {
    readonly _tag: "Sequential";
    readonly left: CauseEncoded<E>;
    readonly right: CauseEncoded<E>;
} | {
    readonly _tag: "Parallel";
    readonly left: CauseEncoded<E>;
    readonly right: CauseEncoded<E>;
};
/**
 * @category api interface
 * @since 0.67.0
 */
export interface CauseFromSelf<E extends Schema.Any, DR> extends AnnotableClass<CauseFromSelf<E, DR>, cause_.Cause<Schema.Type<E>>, cause_.Cause<Schema.Encoded<E>>, Schema.Context<E> | DR> {
}
/**
 * @category Cause transformations
 * @since 0.67.0
 */
export declare const CauseFromSelf: <E extends Schema.Any, DR = never>({ defect, error }: {
    readonly error: E;
    readonly defect?: Schema<unknown, unknown, DR> | undefined;
}) => CauseFromSelf<E, DR>;
/**
 * @category Cause transformations
 * @since 0.67.0
 */
export declare const CauseDefectUnknown: transform<typeof Unknown, typeof Unknown>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Cause<E extends Schema.All, DR> extends AnnotableClass<Cause<E, DR>, cause_.Cause<Schema.Type<E>>, CauseEncoded<Schema.Encoded<E>>, Schema.Context<E> | DR> {
}
/**
 * @category Cause transformations
 * @since 0.67.0
 */
export declare const Cause: <E extends Schema.All, DR = never>({ defect, error }: {
    readonly error: E;
    readonly defect?: Schema<unknown, unknown, DR> | undefined;
}) => Cause<E, DR>;
/**
 * @category Exit utils
 * @since 0.67.0
 */
export type ExitEncoded<A, E> = {
    readonly _tag: "Failure";
    readonly cause: CauseEncoded<E>;
} | {
    readonly _tag: "Success";
    readonly value: A;
};
/**
 * @category api interface
 * @since 0.67.0
 */
export interface ExitFromSelf<A extends Schema.Any, E extends Schema.Any, DR> extends AnnotableClass<ExitFromSelf<A, E, DR>, exit_.Exit<Schema.Type<A>, Schema.Type<E>>, exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>, Schema.Context<A> | Schema.Context<E> | DR> {
}
/**
 * @category Exit transformations
 * @since 0.67.0
 */
export declare const ExitFromSelf: <A extends Schema.Any, E extends Schema.Any, DR = never>({ defect, failure, success }: {
    readonly failure: E;
    readonly success: A;
    readonly defect?: Schema<unknown, unknown, DR> | undefined;
}) => ExitFromSelf<A, E, DR>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface Exit<A extends Schema.All, E extends Schema.All, DR> extends AnnotableClass<Exit<A, E, DR>, exit_.Exit<Schema.Type<A>, Schema.Type<E>>, ExitEncoded<Schema.Encoded<A>, Schema.Encoded<E>>, Schema.Context<A> | Schema.Context<E> | DR> {
}
/**
 * @category Exit transformations
 * @since 0.67.0
 */
export declare const Exit: <A extends Schema.All, E extends Schema.All, DR = never>({ defect, failure, success }: {
    readonly failure: E;
    readonly success: A;
    readonly defect?: Schema<unknown, unknown, DR> | undefined;
}) => Exit<A, E, DR>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface HashSetFromSelf<Value extends Schema.Any> extends AnnotableClass<HashSetFromSelf<Value>, hashSet_.HashSet<Schema.Type<Value>>, hashSet_.HashSet<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category HashSet transformations
 * @since 0.67.0
 */
export declare const HashSetFromSelf: <Value extends Schema.Any>(value: Value) => HashSetFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface HashSet<Value extends Schema.Any> extends AnnotableClass<HashSet<Value>, hashSet_.HashSet<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category HashSet transformations
 * @since 0.67.0
 */
export declare const HashSet: <Value extends Schema.Any>(value: Value) => HashSet<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends AnnotableClass<HashMapFromSelf<K, V>, hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>, hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category HashMap transformations
 * @since 0.67.0
 */
export declare const HashMapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => HashMapFromSelf<K, V>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface HashMap<K extends Schema.Any, V extends Schema.Any> extends AnnotableClass<HashMap<K, V>, hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>, ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category HashMap transformations
 * @since 0.67.0
 */
export declare const HashMap: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => HashMap<K, V>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface ListFromSelf<Value extends Schema.Any> extends AnnotableClass<ListFromSelf<Value>, list_.List<Schema.Type<Value>>, list_.List<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category List transformations
 * @since 0.67.0
 */
export declare const ListFromSelf: <Value extends Schema.Any>(value: Value) => ListFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface List<Value extends Schema.Any> extends AnnotableClass<List<Value>, list_.List<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category List transformations
 * @since 0.67.0
 */
export declare const List: <Value extends Schema.Any>(value: Value) => List<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface SortedSetFromSelf<Value extends Schema.Any> extends AnnotableClass<SortedSetFromSelf<Value>, sortedSet_.SortedSet<Schema.Type<Value>>, sortedSet_.SortedSet<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category SortedSet transformations
 * @since 0.67.0
 */
export declare const SortedSetFromSelf: <Value extends Schema.Any>(value: Value, ordA: Order.Order<Schema.Type<Value>>, ordI: Order.Order<Schema.Encoded<Value>>) => SortedSetFromSelf<Value>;
/**
 * @category api interface
 * @since 0.67.0
 */
export interface SortedSet<Value extends Schema.Any> extends AnnotableClass<SortedSet<Value>, sortedSet_.SortedSet<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category SortedSet transformations
 * @since 0.67.0
 */
export declare const SortedSet: <Value extends Schema.Any>(value: Value, ordA: Order.Order<Schema.Type<Value>>) => SortedSet<Value>;
declare const BooleanFromUnknown_base: transform<typeof Unknown, typeof Boolean$>;
/**
 * Converts an arbitrary value to a `boolean` by testing whether it is truthy.
 * Uses `!!val` to coerce the value to a `boolean`.
 *
 * @see https://developer.mozilla.org/docs/Glossary/Truthy
 * @category boolean constructors
 * @since 0.67.0
 */
export declare class BooleanFromUnknown extends BooleanFromUnknown_base {
}
/**
 * @category Config validations
 * @since 0.67.12
 */
export declare const Config: <A>(name: string, schema: Schema<A, string>) => config_.Config<A>;
//# sourceMappingURL=Schema.d.ts.map
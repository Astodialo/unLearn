"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = exports.DEFINITION_PREFIX = void 0;
var Option = _interopRequireWildcard(require("effect/Option"));
var Predicate = _interopRequireWildcard(require("effect/Predicate"));
var Record = _interopRequireWildcard(require("effect/Record"));
var AST = _interopRequireWildcard(require("./AST.js"));
var errors_ = _interopRequireWildcard(require("./internal/errors.js"));
var filters_ = _interopRequireWildcard(require("./internal/filters.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @since 0.67.0
 */

/**
 * @category encoding
 * @since 0.67.0
 */
const make = schema => {
  const $defs = {};
  const jsonSchema = go(schema.ast, $defs, true, []);
  const out = {
    $schema,
    ...jsonSchema
  };
  // clean up self-referencing entries
  for (const id in $defs) {
    if ($defs[id]["$ref"] === get$ref(id)) {
      delete $defs[id];
    }
  }
  if (!Record.isEmptyRecord($defs)) {
    out.$defs = $defs;
  }
  return out;
};
exports.make = make;
const anyJsonSchema = {
  $id: "/schemas/any"
};
const unknownJsonSchema = {
  $id: "/schemas/unknown"
};
const objectJsonSchema = {
  "$id": "/schemas/object",
  "oneOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
const empty = () => ({
  "$id": "/schemas/{}",
  "oneOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
});
const $schema = "http://json-schema.org/draft-07/schema#";
const getJsonSchemaAnnotations = annotated => Record.getSomes({
  description: AST.getDescriptionAnnotation(annotated),
  title: AST.getTitleAnnotation(annotated),
  examples: AST.getExamplesAnnotation(annotated),
  default: AST.getDefaultAnnotation(annotated)
});
const pruneUndefinedKeyword = ps => {
  const type = ps.type;
  if (AST.isUnion(type) && Option.isNone(AST.getJSONSchemaAnnotation(type))) {
    const types = type.types.filter(type => !AST.isUndefinedKeyword(type));
    if (types.length < type.types.length) {
      return AST.Union.make(types, type.annotations);
    }
  }
};
/** @internal */
const DEFINITION_PREFIX = exports.DEFINITION_PREFIX = "#/$defs/";
const get$ref = id => `${DEFINITION_PREFIX}${id}`;
const getRefinementInnerTransformation = ast => {
  switch (ast.from._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getRefinementInnerTransformation(ast.from);
    case "Suspend":
      {
        const from = ast.from.f();
        if (AST.isRefinement(from)) {
          return getRefinementInnerTransformation(from);
        }
      }
  }
};
const isParseJsonTransformation = ast => ast.annotations[AST.TypeAnnotationId] === filters_.ParseJsonTypeId;
function merge(a, b) {
  return {
    ...a,
    ...b
  };
}
const isOverrideAnnotation = jsonSchema => {
  return "type" in jsonSchema || "oneOf" in jsonSchema || "anyOf" in jsonSchema || "const" in jsonSchema || "enum" in jsonSchema || "$ref" in jsonSchema;
};
const go = (ast, $defs, handleIdentifier, path) => {
  const hook = AST.getJSONSchemaAnnotation(ast);
  if (Option.isSome(hook)) {
    const handler = hook.value;
    if (AST.isRefinement(ast)) {
      const t = getRefinementInnerTransformation(ast);
      if (t === undefined) {
        try {
          return merge(merge(go(ast.from, $defs, true, path), getJsonSchemaAnnotations(ast)), handler);
        } catch (e) {
          return merge(getJsonSchemaAnnotations(ast), handler);
        }
      } else if (!isOverrideAnnotation(handler)) {
        return go(t, $defs, true, path);
      }
    }
    return handler;
  }
  const surrogate = AST.getSurrogateAnnotation(ast);
  if (Option.isSome(surrogate)) {
    return go(surrogate.value, $defs, handleIdentifier, path);
  }
  if (handleIdentifier && !AST.isTransformation(ast)) {
    const identifier = AST.getJSONIdentifier(ast);
    if (Option.isSome(identifier)) {
      const id = identifier.value;
      const out = {
        $ref: get$ref(id)
      };
      if (!Record.has($defs, id)) {
        $defs[id] = out;
        $defs[id] = go(ast, $defs, false, path);
      }
      return out;
    }
  }
  switch (ast._tag) {
    case "Declaration":
      throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "Literal":
      {
        const literal = ast.literal;
        if (literal === null) {
          return merge({
            const: null
          }, getJsonSchemaAnnotations(ast));
        } else if (Predicate.isString(literal) || Predicate.isNumber(literal) || Predicate.isBoolean(literal)) {
          return merge({
            const: literal
          }, getJsonSchemaAnnotations(ast));
        }
        throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
      }
    case "UniqueSymbol":
      throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "UndefinedKeyword":
      throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "VoidKeyword":
      throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "NeverKeyword":
      throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "UnknownKeyword":
      return merge(unknownJsonSchema, getJsonSchemaAnnotations(ast));
    case "AnyKeyword":
      return merge(anyJsonSchema, getJsonSchemaAnnotations(ast));
    case "ObjectKeyword":
      return merge(objectJsonSchema, getJsonSchemaAnnotations(ast));
    case "StringKeyword":
      {
        const out = {
          type: "string"
        };
        return ast === AST.stringKeyword ? out : merge(out, getJsonSchemaAnnotations(ast));
      }
    case "NumberKeyword":
      {
        const out = {
          type: "number"
        };
        return ast === AST.numberKeyword ? out : merge(out, getJsonSchemaAnnotations(ast));
      }
    case "BooleanKeyword":
      {
        const out = {
          type: "boolean"
        };
        return ast === AST.booleanKeyword ? out : merge(out, getJsonSchemaAnnotations(ast));
      }
    case "BigIntKeyword":
      throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "SymbolKeyword":
      throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "TupleType":
      {
        const elements = ast.elements.map((e, i) => merge(go(e.type, $defs, true, path.concat(i)), getJsonSchemaAnnotations(e)));
        const rest = ast.rest.map(annotatedAST => merge(go(annotatedAST.type, $defs, true, path), getJsonSchemaAnnotations(annotatedAST)));
        const output = {
          type: "array"
        };
        // ---------------------------------------------
        // handle elements
        // ---------------------------------------------
        const len = ast.elements.length;
        if (len > 0) {
          output.minItems = len - ast.elements.filter(element => element.isOptional).length;
          output.items = elements;
        }
        // ---------------------------------------------
        // handle rest element
        // ---------------------------------------------
        const restLength = rest.length;
        if (restLength > 0) {
          const head = rest[0];
          const isHomogeneous = restLength === 1 && ast.elements.every(e => e.type === ast.rest[0].type);
          if (isHomogeneous) {
            output.items = head;
          } else {
            output.additionalItems = head;
          }
          // ---------------------------------------------
          // handle post rest elements
          // ---------------------------------------------
          if (restLength > 1) {
            throw new Error(errors_.getJSONSchemaUnsupportedPostRestElementsErrorMessage(path));
          }
        } else {
          if (len > 0) {
            output.additionalItems = false;
          } else {
            output.maxItems = 0;
          }
        }
        return merge(output, getJsonSchemaAnnotations(ast));
      }
    case "TypeLiteral":
      {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return merge(empty(), getJsonSchemaAnnotations(ast));
        }
        let patternProperties = undefined;
        let propertyNames = undefined;
        for (const is of ast.indexSignatures) {
          const parameter = is.parameter;
          switch (parameter._tag) {
            case "StringKeyword":
              {
                patternProperties = go(is.type, $defs, true, path);
                break;
              }
            case "TemplateLiteral":
              {
                patternProperties = go(is.type, $defs, true, path);
                propertyNames = {
                  type: "string",
                  pattern: AST.getTemplateLiteralRegExp(parameter).source
                };
                break;
              }
            case "Refinement":
              {
                patternProperties = go(is.type, $defs, true, path);
                propertyNames = go(parameter, $defs, true, path);
                break;
              }
            case "SymbolKeyword":
              throw new Error(errors_.getJSONSchemaUnsupportedParameterErrorMessage(path, parameter));
          }
        }
        const output = {
          type: "object",
          required: [],
          properties: {},
          additionalProperties: false
        };
        // ---------------------------------------------
        // handle property signatures
        // ---------------------------------------------
        for (let i = 0; i < ast.propertySignatures.length; i++) {
          const ps = ast.propertySignatures[i];
          const name = ps.name;
          if (Predicate.isString(name)) {
            const pruned = pruneUndefinedKeyword(ps);
            output.properties[name] = merge(go(pruned ? pruned : ps.type, $defs, true, path.concat(ps.name)), getJsonSchemaAnnotations(ps));
            // ---------------------------------------------
            // handle optional property signatures
            // ---------------------------------------------
            if (!ps.isOptional && pruned === undefined) {
              output.required.push(name);
            }
          } else {
            throw new Error(errors_.getJSONSchemaUnsupportedKeyErrorMessage(name, path));
          }
        }
        // ---------------------------------------------
        // handle index signatures
        // ---------------------------------------------
        if (patternProperties !== undefined) {
          delete output.additionalProperties;
          output.patternProperties = {
            "": patternProperties
          };
        }
        if (propertyNames !== undefined) {
          output.propertyNames = propertyNames;
        }
        return merge(output, getJsonSchemaAnnotations(ast));
      }
    case "Union":
      {
        const enums = [];
        const anyOf = [];
        for (const type of ast.types) {
          const schema = go(type, $defs, true, path);
          if ("const" in schema) {
            if (Object.keys(schema).length > 1) {
              anyOf.push(schema);
            } else {
              enums.push(schema.const);
            }
          } else {
            anyOf.push(schema);
          }
        }
        if (anyOf.length === 0) {
          if (enums.length === 1) {
            return merge({
              const: enums[0]
            }, getJsonSchemaAnnotations(ast));
          } else {
            return merge({
              enum: enums
            }, getJsonSchemaAnnotations(ast));
          }
        } else {
          if (enums.length === 1) {
            anyOf.push({
              const: enums[0]
            });
          } else if (enums.length > 1) {
            anyOf.push({
              enum: enums
            });
          }
          return merge({
            anyOf
          }, getJsonSchemaAnnotations(ast));
        }
      }
    case "Enums":
      {
        return merge({
          $comment: "/schemas/enums",
          oneOf: ast.enums.map(e => ({
            title: e[0],
            const: e[1]
          }))
        }, getJsonSchemaAnnotations(ast));
      }
    case "Refinement":
      {
        throw new Error(errors_.getJSONSchemaMissingAnnotationErrorMessage(path, ast));
      }
    case "TemplateLiteral":
      {
        const regex = AST.getTemplateLiteralRegExp(ast);
        return merge({
          type: "string",
          description: "a template literal",
          pattern: regex.source
        }, getJsonSchemaAnnotations(ast));
      }
    case "Suspend":
      {
        const identifier = Option.orElse(AST.getJSONIdentifier(ast), () => AST.getJSONIdentifier(ast.f()));
        if (Option.isNone(identifier)) {
          throw new Error(errors_.getJSONSchemaMissingIdentifierAnnotationErrorMessage(path, ast));
        }
        return go(ast.f(), $defs, true, path);
      }
    case "Transformation":
      {
        // Properly handle S.parseJson transformations by focusing on
        // the 'to' side of the AST. This approach prevents the generation of useless schemas
        // derived from the 'from' side (type: string), ensuring the output matches the intended
        // complex schema type.
        const next = isParseJsonTransformation(ast.from) ? ast.to : ast.from;
        return go(next, $defs, true, path);
      }
  }
};
//# sourceMappingURL=JSONSchema.js.map